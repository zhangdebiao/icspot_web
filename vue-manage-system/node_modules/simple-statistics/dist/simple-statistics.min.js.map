{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","src/add_to_mean.js","src/bayesian_classifier.js","src/bernoulli_distribution.js","src/binomial_distribution.js","src/bisect.js","src/chi_squared_distribution_table.js","src/chi_squared_goodness_of_fit.js","src/chunk.js","src/ckmeans.js","src/combinations.js","src/combinations_replacement.js","src/combine_means.js","src/combine_variances.js","src/cumulative_std_normal_probability.js","src/epsilon.js","src/equal_interval_breaks.js","src/error_function.js","src/factorial.js","src/geometric_mean.js","src/harmonic_mean.js","src/interquartile_range.js","src/inverse_error_function.js","src/linear_regression.js","src/linear_regression_line.js","src/max.js","src/max_sorted.js","src/mean.js","src/median.js","src/median_absolute_deviation.js","src/median_sorted.js","src/min.js","src/min_sorted.js","src/mode.js","src/mode_fast.js","src/mode_sorted.js","src/numeric_sort.js","src/perceptron.js","src/permutations_heap.js","src/poisson_distribution.js","src/probit.js","src/product.js","src/quantile.js","src/quantile_sorted.js","src/quickselect.js","src/r_squared.js","src/root_mean_square.js","src/sample.js","src/sample_correlation.js","src/sample_covariance.js","src/sample_kurtosis.js","src/sample_skewness.js","src/sample_standard_deviation.js","src/sample_variance.js","src/sample_with_replacement.js","src/shuffle.js","src/shuffle_in_place.js","src/sign.js","src/standard_deviation.js","src/standard_normal_table.js","src/subtract_from_mean.js","src/sum.js","src/sum_nth_power_deviations.js","src/sum_simple.js","src/t_test.js","src/t_test_two_sample.js","src/unique_count_sorted.js","src/variance.js","src/z_score.js"],"names":["f","exports","module","define","amd","window","global","self","this","ss","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","linearRegression","linearRegressionLine","standardDeviation","rSquared","mode","modeFast","modeSorted","min","max","minSorted","maxSorted","sum","sumSimple","product","quantile","quantileSorted","interquartileRange","iqr","medianAbsoluteDeviation","mad","chunk","sampleWithReplacement","shuffle","shuffleInPlace","sample","ckmeans","uniqueCountSorted","sumNthPowerDeviations","equalIntervalBreaks","sampleCovariance","sampleCorrelation","sampleVariance","sampleStandardDeviation","sampleSkewness","sampleKurtosis","permutationsHeap","combinations","combinationsReplacement","addToMean","combineMeans","combineVariances","geometricMean","harmonicMean","mean","average","median","medianSorted","subtractFromMean","rootMeanSquare","rms","variance","tTest","tTestTwoSample","BayesianClassifier","bayesian","PerceptronModel","perceptron","epsilon","factorial","bernoulliDistribution","binomialDistribution","poissonDistribution","chiSquaredGoodnessOfFit","zScore","cumulativeStdNormalProbability","standardNormalTable","errorFunction","erf","inverseErrorFunction","probit","bisect","newValue","totalCount","data","prototype","train","item","category","k","v","undefined","score","odds","oddsSums","combination","p","trials","probability","x","cumulativeProbability","cells","binomialCoefficient","Math","pow","sign","func","start","end","maxIterations","errorTolerance","TypeError","output","abs","chiSquaredDistributionTable","0.995","0.99","0.975","0.95","0.9","0.5","0.1","0.05","0.025","0.01","0.005","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","40","50","60","70","80","90","100","distributionType","significance","degreesOfFreedom","chiSquared","hypothesizedDistribution","observedFrequencies","expectedFrequencies","pop","chunkSize","floor","push","slice","makeMatrix","columns","rows","matrix","column","j","ssq","sums","sumsOfSquares","sji","muji","fillMatrixColumn","iMin","iMax","cluster","backtrackMatrix","jlow","jhigh","ssqjlow","ssqj","fillMatrices","shiftedValue","nValues","shift","numericSort","nClusters","sorted","clusters","clusterRight","clusterLeft","subI","subsetCombinations","next","combinationList","unshift","concat","mean1","n1","mean2","n2","variance1","variance2","newMean","z","absZ","index","round","toFixed","nClasses","theMin","theMax","breaks","breakSize","tau","exp","accumulator","value","reciprocalSum","q1","q2","PI","inv","sqrt","log","m","b","dataLength","point","y","sumX","sumY","sumXX","sumXY","mb","medianValue","medianAbsoluteDeviations","Map","modeCount","newCount","get","set","last","NaN","maxSeen","seenThis","sort","weights","bias","predict","features","label","prediction","gradient","elements","indexes","Array","permutations","swapFrom","temp","lambda","factorialX","quantileSelect","arr","left","right","quickselect","multiQuantileSelect","indices","quantileIndex","compare","stack","ceil","len","idx","copy","isArray","results","sd","swap","tmp","sumOfSquares","err","randomSource","xmean","ymean","tempValue","meanValue","secondCentralMoment","fourthCentralMoment","sumSquaredDeviations","sumCubedDeviations","besselsCorrection","theSampleStandardDeviation","sampleVarianceX","random","temporary","SQRT_2PI","cumulativeDistribution","transition","correction","expectedValue","sampleX","sampleY","difference","meanX","meanY","sampleVarianceY","weightedVariance","lastSeenValue","uniqueValueCount"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* @flow */\n'use strict';\n\n// # simple-statistics\n//\n// A simple, literate statistics system.\n\nvar ss = module.exports = {};\n\n// Linear Regression\nss.linearRegression = require(24);\nss.linearRegressionLine = require(25);\nss.standardDeviation = require(59);\nss.rSquared = require(46);\nss.mode = require(34);\nss.modeFast = require(35);\nss.modeSorted = require(36);\nss.min = require(32);\nss.max = require(26);\nss.minSorted = require(33);\nss.maxSorted = require(27);\nss.sum = require(62);\nss.sumSimple = require(64);\nss.product = require(42);\nss.quantile = require(43);\nss.quantileSorted = require(44);\nss.interquartileRange = ss.iqr = require(22);\nss.medianAbsoluteDeviation = ss.mad = require(30);\nss.chunk = require(9);\nss.sampleWithReplacement = require(55);\nss.shuffle = require(56);\nss.shuffleInPlace = require(57);\nss.sample = require(48);\nss.ckmeans = require(10);\nss.uniqueCountSorted = require(67);\nss.sumNthPowerDeviations = require(63);\nss.equalIntervalBreaks = require(17);\n\n// sample statistics\nss.sampleCovariance = require(50);\nss.sampleCorrelation = require(49);\nss.sampleVariance = require(54);\nss.sampleStandardDeviation = require(53);\nss.sampleSkewness = require(52);\nss.sampleKurtosis = require(51);\n\n// combinatorics\nss.permutationsHeap = require(39);\nss.combinations = require(11);\nss.combinationsReplacement = require(12);\n\n// measures of centrality\nss.addToMean = require(2);\nss.combineMeans = require(13);\nss.combineVariances = require(14);\nss.geometricMean = require(20);\nss.harmonicMean = require(21);\nss.mean = ss.average = require(28);\nss.median = require(29);\nss.medianSorted = require(31);\nss.subtractFromMean = require(61);\n\nss.rootMeanSquare = ss.rms = require(47);\nss.variance = require(68);\nss.tTest = require(65);\nss.tTestTwoSample = require(66);\n// ss.jenks = require('./src/jenks');\n\n// Classifiers\nss.BayesianClassifier = ss.bayesian = require(3);\nss.PerceptronModel = ss.perceptron = require(38);\n\n// Distribution-related methods\nss.epsilon = require(16); // We make ε available to the test suite.\nss.factorial = require(19);\nss.bernoulliDistribution = require(4);\nss.binomialDistribution = require(5);\nss.poissonDistribution = require(40);\nss.chiSquaredGoodnessOfFit = require(8);\n\n// Normal distribution\nss.zScore = require(69);\nss.cumulativeStdNormalProbability = require(15);\nss.standardNormalTable = require(60);\nss.errorFunction = ss.erf = require(18);\nss.inverseErrorFunction = require(23);\nss.probit = require(41);\n\n// Root-finding methods\nss.bisect = require(6);\n","'use strict';\n/* @flow */\n\n/**\n * When adding a new value to a list, one does not have to necessary\n * recompute the mean of the list in linear time. They can instead use\n * this function to compute the new mean by providing the current mean,\n * the number of elements in the list that produced it and the new\n * value to add.\n *\n * @since 2.5.0\n * @param {number} mean current mean\n * @param {number} n number of items in the list\n * @param {number} newValue the added value\n * @returns {number} the new mean\n *\n * @example\n * addToMean(14, 5, 53); // => 20.5\n */\nfunction addToMean(mean /*: number*/, n/*: number */, newValue/*: number */)/*: number */ {\n    return mean + ((newValue - mean) / (n + 1));\n}\n\nmodule.exports = addToMean;\n","'use strict';\n/* @flow */\n\n/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nfunction BayesianClassifier() {\n    // The number of items that are currently\n    // classified in the model\n    this.totalCount = 0;\n    // Every item classified in the model\n    this.data = {};\n}\n\n/**\n * Train the classifier with a new item, which has a single\n * dimension of Javascript literal keys and values.\n *\n * @param {Object} item an object with singly-deep properties\n * @param {string} category the category this item belongs to\n * @return {undefined} adds the item to the classifier\n */\nBayesianClassifier.prototype.train = function(item, category) {\n    // If the data object doesn't have any values\n    // for this category, create a new object for it.\n    if (!this.data[category]) {\n        this.data[category] = {};\n    }\n\n    // Iterate through each key in the item.\n    for (var k in item) {\n        var v = item[k];\n        // Initialize the nested object `data[category][k][item[k]]`\n        // with an object of keys that equal 0.\n        if (this.data[category][k] === undefined) {\n            this.data[category][k] = {};\n        }\n        if (this.data[category][k][v] === undefined) {\n            this.data[category][k][v] = 0;\n        }\n\n        // And increment the key for this key/value combination.\n        this.data[category][k][v]++;\n    }\n\n    // Increment the number of items classified\n    this.totalCount++;\n};\n\n/**\n * Generate a score of how well this item matches all\n * possible categories based on its attributes\n *\n * @param {Object} item an item in the same format as with train\n * @returns {Object} of probabilities that this item belongs to a\n * given category.\n */\nBayesianClassifier.prototype.score = function(item) {\n    // Initialize an empty array of odds per category.\n    var odds = {}, category;\n    // Iterate through each key in the item,\n    // then iterate through each category that has been used\n    // in previous calls to `.train()`\n    for (var k in item) {\n        var v = item[k];\n        for (category in this.data) {\n            // Create an empty object for storing key - value combinations\n            // for this category.\n            odds[category] = {};\n\n            // If this item doesn't even have a property, it counts for nothing,\n            // but if it does have the property that we're looking for from\n            // the item to categorize, it counts based on how popular it is\n            // versus the whole population.\n            if (this.data[category][k]) {\n                odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount;\n            } else {\n                odds[category][k + '_' + v] = 0;\n            }\n        }\n    }\n\n    // Set up a new object that will contain sums of these odds by category\n    var oddsSums = {};\n\n    for (category in odds) {\n        // Tally all of the odds for each category-combination pair -\n        // the non-existence of a category does not add anything to the\n        // score.\n        oddsSums[category] = 0;\n        for (var combination in odds[category]) {\n            oddsSums[category] += odds[category][combination];\n        }\n    }\n\n    return oddsSums;\n};\n\nmodule.exports = BayesianClassifier;\n","'use strict';\n/* @flow */\n\n/**\n * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)\n * is the probability discrete\n * distribution of a random variable which takes value 1 with success\n * probability `p` and value 0 with failure\n * probability `q` = 1 - `p`. It can be used, for example, to represent the\n * toss of a coin, where \"1\" is defined to mean \"heads\" and \"0\" is defined\n * to mean \"tails\" (or vice versa). It is\n * a special case of a Binomial Distribution\n * where `n` = 1.\n *\n * @param {number} p input value, between 0 and 1 inclusive\n * @returns {number[]} values of bernoulli distribution at this point\n * @throws {Error} if p is outside 0 and 1\n * @example\n * bernoulliDistribution(0.3); // => [0.7, 0.3]\n */\nfunction bernoulliDistribution(p/*: number */) /*: number[] */ {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1)\n    if (p < 0 || p > 1 ) {\n        throw new Error('bernoulliDistribution requires probability to be between 0 and 1 inclusive');\n    }\n\n    return [1 - p, p];\n}\n\nmodule.exports = bernoulliDistribution;\n","'use strict';\n/* @flow */\n\nvar epsilon = require(16);\n\n/**\n * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability\n * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields\n * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or\n * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.\n *\n * @param {number} trials number of trials to simulate\n * @param {number} probability\n * @returns {number[]} output\n */\nfunction binomialDistribution(\n    trials/*: number */,\n    probability/*: number */)/*: ?number[] */ {\n    // Check that `p` is a valid probability (0 ≤ p ≤ 1),\n    // that `n` is an integer, strictly positive.\n    if (probability < 0 || probability > 1 ||\n        trials <= 0 || trials % 1 !== 0) {\n        return undefined;\n    }\n\n    // We initialize `x`, the random variable, and `accumulator`, an accumulator\n    // for the cumulative distribution function to 0. `distribution_functions`\n    // is the object we'll return with the `probability_of_x` and the\n    // `cumulativeProbability_of_x`, as well as the calculated mean &\n    // variance. We iterate until the `cumulativeProbability_of_x` is\n    // within `epsilon` of 1.0.\n    var x = 0,\n        cumulativeProbability = 0,\n        cells = [],\n        binomialCoefficient = 1;\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = binomialCoefficient *\n            Math.pow(probability, x) * Math.pow(1 - probability, trials - x);\n        cumulativeProbability += cells[x];\n        x++;\n        binomialCoefficient = binomialCoefficient * (trials - x + 1) / x;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = binomialDistribution;\n","'use strict';\n/* @flow */\n\nvar sign = require(58);\n/**\n * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding \n * method that repeatedly bisects an interval to find the root.\n * \n * This function returns a numerical approximation to the exact value.\n * \n * @param {Function} func input function\n * @param {Number} start - start of interval\n * @param {Number} end - end of interval\n * @param {Number} maxIterations - the maximum number of iterations\n * @param {Number} errorTolerance - the error tolerance\n * @returns {Number} estimated root value\n * @throws {TypeError} Argument func must be a function\n * \n * @example\n * bisect(Math.cos,0,4,100,0.003); // => 1.572265625\n */\nfunction bisect(\n    func/*: (x: any) => number */,\n    start/*: number */,\n    end/*: number */,\n    maxIterations/*: number */,\n    errorTolerance/*: number */)/*:number*/ {\n\n    if (typeof func !== 'function') throw new TypeError('func must be a function');\n    \n    for (var i = 0; i < maxIterations; i++) {\n        var output = (start + end) / 2;\n\n        if (func(output) === 0 || Math.abs((end - start) / 2) < errorTolerance) {\n            return output;\n        }\n\n        if (sign(func(output)) === sign(func(start))) {\n            start = output;\n        } else {\n            end = output;\n        }\n    }\n    \n    throw new Error('maximum number of iterations exceeded');\n}\n\nmodule.exports = bisect;\n","'use strict';\n/* @flow */\n\n/**\n * **Percentage Points of the χ2 (Chi-Squared) Distribution**\n *\n * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common\n * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two\n * criteria of classification of qualitative data, and in confidence interval estimation for a population standard\n * deviation of a normal distribution from a sample standard deviation.\n *\n * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, \"Probability and Statistics in\n * Engineering and Management Science\", Wiley (1980).\n */\nvar chiSquaredDistributionTable = {\n    '1': {\n        '0.995': 0,\n        '0.99': 0,\n        '0.975': 0,\n        '0.95': 0,\n        '0.9': 0.02,\n        '0.5': 0.45,\n        '0.1': 2.71,\n        '0.05': 3.84,\n        '0.025': 5.02,\n        '0.01': 6.63,\n        '0.005': 7.88\n    },\n    '2': {\n        '0.995': 0.01,\n        '0.99': 0.02,\n        '0.975': 0.05,\n        '0.95': 0.1,\n        '0.9': 0.21,\n        '0.5': 1.39,\n        '0.1': 4.61,\n        '0.05': 5.99,\n        '0.025': 7.38,\n        '0.01': 9.21,\n        '0.005': 10.6\n    },\n    '3': {\n        '0.995': 0.07,\n        '0.99': 0.11,\n        '0.975': 0.22,\n        '0.95': 0.35,\n        '0.9': 0.58,\n        '0.5': 2.37,\n        '0.1': 6.25,\n        '0.05': 7.81,\n        '0.025': 9.35,\n        '0.01': 11.34,\n        '0.005': 12.84\n    },\n    '4': {\n        '0.995': 0.21,\n        '0.99': 0.3,\n        '0.975': 0.48,\n        '0.95': 0.71,\n        '0.9': 1.06,\n        '0.5': 3.36,\n        '0.1': 7.78,\n        '0.05': 9.49,\n        '0.025': 11.14,\n        '0.01': 13.28,\n        '0.005': 14.86\n    },\n    '5': {\n        '0.995': 0.41,\n        '0.99': 0.55,\n        '0.975': 0.83,\n        '0.95': 1.15,\n        '0.9': 1.61,\n        '0.5': 4.35,\n        '0.1': 9.24,\n        '0.05': 11.07,\n        '0.025': 12.83,\n        '0.01': 15.09,\n        '0.005': 16.75\n    },\n    '6': {\n        '0.995': 0.68,\n        '0.99': 0.87,\n        '0.975': 1.24,\n        '0.95': 1.64,\n        '0.9': 2.2,\n        '0.5': 5.35,\n        '0.1': 10.65,\n        '0.05': 12.59,\n        '0.025': 14.45,\n        '0.01': 16.81,\n        '0.005': 18.55\n    },\n    '7': {\n        '0.995': 0.99,\n        '0.99': 1.25,\n        '0.975': 1.69,\n        '0.95': 2.17,\n        '0.9': 2.83,\n        '0.5': 6.35,\n        '0.1': 12.02,\n        '0.05': 14.07,\n        '0.025': 16.01,\n        '0.01': 18.48,\n        '0.005': 20.28\n    },\n    '8': {\n        '0.995': 1.34,\n        '0.99': 1.65,\n        '0.975': 2.18,\n        '0.95': 2.73,\n        '0.9': 3.49,\n        '0.5': 7.34,\n        '0.1': 13.36,\n        '0.05': 15.51,\n        '0.025': 17.53,\n        '0.01': 20.09,\n        '0.005': 21.96\n    },\n    '9': {\n        '0.995': 1.73,\n        '0.99': 2.09,\n        '0.975': 2.7,\n        '0.95': 3.33,\n        '0.9': 4.17,\n        '0.5': 8.34,\n        '0.1': 14.68,\n        '0.05': 16.92,\n        '0.025': 19.02,\n        '0.01': 21.67,\n        '0.005': 23.59\n    },\n    '10': {\n        '0.995': 2.16,\n        '0.99': 2.56,\n        '0.975': 3.25,\n        '0.95': 3.94,\n        '0.9': 4.87,\n        '0.5': 9.34,\n        '0.1': 15.99,\n        '0.05': 18.31,\n        '0.025': 20.48,\n        '0.01': 23.21,\n        '0.005': 25.19\n    },\n    '11': {\n        '0.995': 2.6,\n        '0.99': 3.05,\n        '0.975': 3.82,\n        '0.95': 4.57,\n        '0.9': 5.58,\n        '0.5': 10.34,\n        '0.1': 17.28,\n        '0.05': 19.68,\n        '0.025': 21.92,\n        '0.01': 24.72,\n        '0.005': 26.76\n    },\n    '12': {\n        '0.995': 3.07,\n        '0.99': 3.57,\n        '0.975': 4.4,\n        '0.95': 5.23,\n        '0.9': 6.3,\n        '0.5': 11.34,\n        '0.1': 18.55,\n        '0.05': 21.03,\n        '0.025': 23.34,\n        '0.01': 26.22,\n        '0.005': 28.3\n    },\n    '13': {\n        '0.995': 3.57,\n        '0.99': 4.11,\n        '0.975': 5.01,\n        '0.95': 5.89,\n        '0.9': 7.04,\n        '0.5': 12.34,\n        '0.1': 19.81,\n        '0.05': 22.36,\n        '0.025': 24.74,\n        '0.01': 27.69,\n        '0.005': 29.82\n    },\n    '14': {\n        '0.995': 4.07,\n        '0.99': 4.66,\n        '0.975': 5.63,\n        '0.95': 6.57,\n        '0.9': 7.79,\n        '0.5': 13.34,\n        '0.1': 21.06,\n        '0.05': 23.68,\n        '0.025': 26.12,\n        '0.01': 29.14,\n        '0.005': 31.32\n    },\n    '15': {\n        '0.995': 4.6,\n        '0.99': 5.23,\n        '0.975': 6.27,\n        '0.95': 7.26,\n        '0.9': 8.55,\n        '0.5': 14.34,\n        '0.1': 22.31,\n        '0.05': 25,\n        '0.025': 27.49,\n        '0.01': 30.58,\n        '0.005': 32.8\n    },\n    '16': {\n        '0.995': 5.14,\n        '0.99': 5.81,\n        '0.975': 6.91,\n        '0.95': 7.96,\n        '0.9': 9.31,\n        '0.5': 15.34,\n        '0.1': 23.54,\n        '0.05': 26.3,\n        '0.025': 28.85,\n        '0.01': 32,\n        '0.005': 34.27\n    },\n    '17': {\n        '0.995': 5.7,\n        '0.99': 6.41,\n        '0.975': 7.56,\n        '0.95': 8.67,\n        '0.9': 10.09,\n        '0.5': 16.34,\n        '0.1': 24.77,\n        '0.05': 27.59,\n        '0.025': 30.19,\n        '0.01': 33.41,\n        '0.005': 35.72\n    },\n    '18': {\n        '0.995': 6.26,\n        '0.99': 7.01,\n        '0.975': 8.23,\n        '0.95': 9.39,\n        '0.9': 10.87,\n        '0.5': 17.34,\n        '0.1': 25.99,\n        '0.05': 28.87,\n        '0.025': 31.53,\n        '0.01': 34.81,\n        '0.005': 37.16\n    },\n    '19': {\n        '0.995': 6.84,\n        '0.99': 7.63,\n        '0.975': 8.91,\n        '0.95': 10.12,\n        '0.9': 11.65,\n        '0.5': 18.34,\n        '0.1': 27.2,\n        '0.05': 30.14,\n        '0.025': 32.85,\n        '0.01': 36.19,\n        '0.005': 38.58\n    },\n    '20': {\n        '0.995': 7.43,\n        '0.99': 8.26,\n        '0.975': 9.59,\n        '0.95': 10.85,\n        '0.9': 12.44,\n        '0.5': 19.34,\n        '0.1': 28.41,\n        '0.05': 31.41,\n        '0.025': 34.17,\n        '0.01': 37.57,\n        '0.005': 40\n    },\n    '21': {\n        '0.995': 8.03,\n        '0.99': 8.9,\n        '0.975': 10.28,\n        '0.95': 11.59,\n        '0.9': 13.24,\n        '0.5': 20.34,\n        '0.1': 29.62,\n        '0.05': 32.67,\n        '0.025': 35.48,\n        '0.01': 38.93,\n        '0.005': 41.4\n    },\n    '22': {\n        '0.995': 8.64,\n        '0.99': 9.54,\n        '0.975': 10.98,\n        '0.95': 12.34,\n        '0.9': 14.04,\n        '0.5': 21.34,\n        '0.1': 30.81,\n        '0.05': 33.92,\n        '0.025': 36.78,\n        '0.01': 40.29,\n        '0.005': 42.8\n    },\n    '23': {\n        '0.995': 9.26,\n        '0.99': 10.2,\n        '0.975': 11.69,\n        '0.95': 13.09,\n        '0.9': 14.85,\n        '0.5': 22.34,\n        '0.1': 32.01,\n        '0.05': 35.17,\n        '0.025': 38.08,\n        '0.01': 41.64,\n        '0.005': 44.18\n    },\n    '24': {\n        '0.995': 9.89,\n        '0.99': 10.86,\n        '0.975': 12.4,\n        '0.95': 13.85,\n        '0.9': 15.66,\n        '0.5': 23.34,\n        '0.1': 33.2,\n        '0.05': 36.42,\n        '0.025': 39.36,\n        '0.01': 42.98,\n        '0.005': 45.56\n    },\n    '25': {\n        '0.995': 10.52,\n        '0.99': 11.52,\n        '0.975': 13.12,\n        '0.95': 14.61,\n        '0.9': 16.47,\n        '0.5': 24.34,\n        '0.1': 34.28,\n        '0.05': 37.65,\n        '0.025': 40.65,\n        '0.01': 44.31,\n        '0.005': 46.93\n    },\n    '26': {\n        '0.995': 11.16,\n        '0.99': 12.2,\n        '0.975': 13.84,\n        '0.95': 15.38,\n        '0.9': 17.29,\n        '0.5': 25.34,\n        '0.1': 35.56,\n        '0.05': 38.89,\n        '0.025': 41.92,\n        '0.01': 45.64,\n        '0.005': 48.29\n    },\n    '27': {\n        '0.995': 11.81,\n        '0.99': 12.88,\n        '0.975': 14.57,\n        '0.95': 16.15,\n        '0.9': 18.11,\n        '0.5': 26.34,\n        '0.1': 36.74,\n        '0.05': 40.11,\n        '0.025': 43.19,\n        '0.01': 46.96,\n        '0.005': 49.65\n    },\n    '28': {\n        '0.995': 12.46,\n        '0.99': 13.57,\n        '0.975': 15.31,\n        '0.95': 16.93,\n        '0.9': 18.94,\n        '0.5': 27.34,\n        '0.1': 37.92,\n        '0.05': 41.34,\n        '0.025': 44.46,\n        '0.01': 48.28,\n        '0.005': 50.99\n    },\n    '29': {\n        '0.995': 13.12,\n        '0.99': 14.26,\n        '0.975': 16.05,\n        '0.95': 17.71,\n        '0.9': 19.77,\n        '0.5': 28.34,\n        '0.1': 39.09,\n        '0.05': 42.56,\n        '0.025': 45.72,\n        '0.01': 49.59,\n        '0.005': 52.34\n    },\n    '30': {\n        '0.995': 13.79,\n        '0.99': 14.95,\n        '0.975': 16.79,\n        '0.95': 18.49,\n        '0.9': 20.6,\n        '0.5': 29.34,\n        '0.1': 40.26,\n        '0.05': 43.77,\n        '0.025': 46.98,\n        '0.01': 50.89,\n        '0.005': 53.67\n    },\n    '40': {\n        '0.995': 20.71,\n        '0.99': 22.16,\n        '0.975': 24.43,\n        '0.95': 26.51,\n        '0.9': 29.05,\n        '0.5': 39.34,\n        '0.1': 51.81,\n        '0.05': 55.76,\n        '0.025': 59.34,\n        '0.01': 63.69,\n        '0.005': 66.77\n    },\n    '50': {\n        '0.995': 27.99,\n        '0.99': 29.71,\n        '0.975': 32.36,\n        '0.95': 34.76,\n        '0.9': 37.69,\n        '0.5': 49.33,\n        '0.1': 63.17,\n        '0.05': 67.5,\n        '0.025': 71.42,\n        '0.01': 76.15,\n        '0.005': 79.49\n    },\n    '60': {\n        '0.995': 35.53,\n        '0.99': 37.48,\n        '0.975': 40.48,\n        '0.95': 43.19,\n        '0.9': 46.46,\n        '0.5': 59.33,\n        '0.1': 74.4,\n        '0.05': 79.08,\n        '0.025': 83.3,\n        '0.01': 88.38,\n        '0.005': 91.95\n    },\n    '70': {\n        '0.995': 43.28,\n        '0.99': 45.44,\n        '0.975': 48.76,\n        '0.95': 51.74,\n        '0.9': 55.33,\n        '0.5': 69.33,\n        '0.1': 85.53,\n        '0.05': 90.53,\n        '0.025': 95.02,\n        '0.01': 100.42,\n        '0.005': 104.22\n    },\n    '80': {\n        '0.995': 51.17,\n        '0.99': 53.54,\n        '0.975': 57.15,\n        '0.95': 60.39,\n        '0.9': 64.28,\n        '0.5': 79.33,\n        '0.1': 96.58,\n        '0.05': 101.88,\n        '0.025': 106.63,\n        '0.01': 112.33,\n        '0.005': 116.32\n    },\n    '90': {\n        '0.995': 59.2,\n        '0.99': 61.75,\n        '0.975': 65.65,\n        '0.95': 69.13,\n        '0.9': 73.29,\n        '0.5': 89.33,\n        '0.1': 107.57,\n        '0.05': 113.14,\n        '0.025': 118.14,\n        '0.01': 124.12,\n        '0.005': 128.3\n    },\n    '100': {\n        '0.995': 67.33,\n        '0.99': 70.06,\n        '0.975': 74.22,\n        '0.95': 77.93,\n        '0.9': 82.36,\n        '0.5': 99.33,\n        '0.1': 118.5,\n        '0.05': 124.34,\n        '0.025': 129.56,\n        '0.01': 135.81,\n        '0.005': 140.17\n    }\n};\n\nmodule.exports = chiSquaredDistributionTable;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\nvar chiSquaredDistributionTable = require(7);\n\n/**\n * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)\n * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies\n * (that is, counts of observations), each squared and divided by the number of observations expected given the\n * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution\n * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one\n * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic\n * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty\n * cells and `c` is the number of estimated parameters for the distribution.\n *\n * @param {Array<number>} data\n * @param {Function} distributionType a function that returns a point in a distribution:\n * for instance, binomial, bernoulli, or poisson\n * @param {number} significance\n * @returns {number} chi squared goodness of fit\n * @example\n * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,\n * // \"Probability and Statistics in Engineering and Management Science\", Wiley (1980).\n * var data1019 = [\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n *     2, 2, 2, 2, 2, 2, 2, 2, 2,\n *     3, 3, 3, 3\n * ];\n * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false\n */\nfunction chiSquaredGoodnessOfFit(\n    data/*: Array<number> */,\n    distributionType/*: Function */,\n    significance/*: number */)/*: boolean */ {\n    // Estimate from the sample data, a weighted mean.\n    var inputMean = mean(data),\n        // Calculated value of the χ2 statistic.\n        chiSquared = 0,\n        // Degrees of freedom, calculated as (number of class intervals -\n        // number of hypothesized distribution parameters estimated - 1)\n        degreesOfFreedom,\n        // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.\n        // Lose one degree of freedom for estimating `lambda` from the sample data.\n        c = 1,\n        // The hypothesized distribution.\n        // Generate the hypothesized distribution.\n        hypothesizedDistribution = distributionType(inputMean),\n        observedFrequencies = [],\n        expectedFrequencies = [],\n        k;\n\n    // Create an array holding a histogram from the sample data, of\n    // the form `{ value: numberOfOcurrences }`\n    for (var i = 0; i < data.length; i++) {\n        if (observedFrequencies[data[i]] === undefined) {\n            observedFrequencies[data[i]] = 0;\n        }\n        observedFrequencies[data[i]]++;\n    }\n\n    // The histogram we created might be sparse - there might be gaps\n    // between values. So we iterate through the histogram, making\n    // sure that instead of undefined, gaps have 0 values.\n    for (i = 0; i < observedFrequencies.length; i++) {\n        if (observedFrequencies[i] === undefined) {\n            observedFrequencies[i] = 0;\n        }\n    }\n\n    // Create an array holding a histogram of expected data given the\n    // sample size and hypothesized distribution.\n    for (k in hypothesizedDistribution) {\n        if (k in observedFrequencies) {\n            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;\n        }\n    }\n\n    // Working backward through the expected frequencies, collapse classes\n    // if less than three observations are expected for a class.\n    // This transformation is applied to the observed frequencies as well.\n    for (k = expectedFrequencies.length - 1; k >= 0; k--) {\n        if (expectedFrequencies[k] < 3) {\n            expectedFrequencies[k - 1] += expectedFrequencies[k];\n            expectedFrequencies.pop();\n\n            observedFrequencies[k - 1] += observedFrequencies[k];\n            observedFrequencies.pop();\n        }\n    }\n\n    // Iterate through the squared differences between observed & expected\n    // frequencies, accumulating the `chiSquared` statistic.\n    for (k = 0; k < observedFrequencies.length; k++) {\n        chiSquared += Math.pow(\n            observedFrequencies[k] - expectedFrequencies[k], 2) /\n            expectedFrequencies[k];\n    }\n\n    // Calculate degrees of freedom for this test and look it up in the\n    // `chiSquaredDistributionTable` in order to\n    // accept or reject the goodness-of-fit of the hypothesized distribution.\n    degreesOfFreedom = observedFrequencies.length - c - 1;\n    return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared;\n}\n\nmodule.exports = chiSquaredGoodnessOfFit;\n","'use strict';\n/* @flow */\n\n/**\n * Split an array into chunks of a specified size. This function\n * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)\n * function, and thus will insert smaller-sized chunks at the end if\n * the input size is not divisible by the chunk size.\n *\n * `x` is expected to be an array, and `chunkSize` a number.\n * The `x` array can contain any kind of data.\n *\n * @param {Array} x a sample\n * @param {number} chunkSize size of each output array. must be a positive integer\n * @returns {Array<Array>} a chunked array\n * @throws {Error} if chunk size is less than 1 or not an integer\n * @example\n * chunk([1, 2, 3, 4, 5, 6], 2);\n * // => [[1, 2], [3, 4], [5, 6]]\n */\nfunction chunk(x/*:Array<any>*/, chunkSize/*:number*/)/*:?Array<Array<any>>*/ {\n\n    // a list of result chunks, as arrays in an array\n    var output = [];\n\n    // `chunkSize` must be zero or higher - otherwise the loop below,\n    // in which we call `start += chunkSize`, will loop infinitely.\n    // So, we'll detect and throw in that case to indicate\n    // invalid input.\n    if (chunkSize < 1) {\n        throw new Error('chunk size must be a positive number');\n    }\n\n    if (Math.floor(chunkSize) !== chunkSize) {\n        throw new Error('chunk size must be an integer');\n    }\n\n    // `start` is the index at which `.slice` will start selecting\n    // new array elements\n    for (var start = 0; start < x.length; start += chunkSize) {\n\n        // for each chunk, slice that part of the array and add it\n        // to the output. The `.slice` function does not change\n        // the original array.\n        output.push(x.slice(start, start + chunkSize));\n    }\n    return output;\n}\n\nmodule.exports = chunk;\n","'use strict';\n/* @flow */\n\nvar uniqueCountSorted = require(67),\n    numericSort = require(37);\n\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} columns\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\nfunction makeMatrix(columns, rows) {\n    var matrix = [];\n    for (var i = 0; i < columns; i++) {\n        var column = [];\n        for (var j = 0; j < rows; j++) {\n            column.push(0);\n        }\n        matrix.push(column);\n    }\n    return matrix;\n}\n\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\nfunction ssq(j, i, sums, sumsOfSquares) {\n    var sji; // s(j, i)\n    if (j > 0) {\n        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n        sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n    } else {\n        sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1);\n    }\n    if (sji < 0) {\n        return 0;\n    }\n    return sji;\n}\n\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\nfunction fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {\n    if (iMin > iMax) {\n        return;\n    }\n\n    // Start at midpoint between iMin and iMax\n    var i = Math.floor((iMin + iMax) / 2);\n\n    matrix[cluster][i] = matrix[cluster - 1][i - 1];\n    backtrackMatrix[cluster][i] = i;\n\n    var jlow = cluster; // the lower end for j\n\n    if (iMin > cluster) {\n        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n    }\n    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n\n    var jhigh = i - 1; // the upper end for j\n    if (iMax < matrix.length - 1) {\n        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n    }\n\n    var sji;\n    var sjlowi;\n    var ssqjlow;\n    var ssqj;\n    for (var j = jhigh; j >= jlow; --j) {\n        sji = ssq(j, i, sums, sumsOfSquares);\n\n        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n            break;\n        }\n\n        // Examine the lower bound of the cluster border\n        sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n\n        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n        if (ssqjlow < matrix[cluster][i]) {\n            // Shrink the lower bound\n            matrix[cluster][i] = ssqjlow;\n            backtrackMatrix[cluster][i] = jlow;\n        }\n        jlow++;\n\n        ssqj = sji + matrix[cluster - 1][j - 1];\n        if (ssqj < matrix[cluster][i]) {\n            matrix[cluster][i] = ssqj;\n            backtrackMatrix[cluster][i] = j;\n        }\n    }\n\n    fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n    fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n}\n\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n    var nValues = matrix[0].length;\n\n    // Shift values by the median to improve numeric stability\n    var shift = data[Math.floor(nValues / 2)];\n\n    // Cumulative sum and cumulative sum of squares for all values in data array\n    var sums = [];\n    var sumsOfSquares = [];\n\n    // Initialize first column in matrix & backtrackMatrix\n    for (var i = 0, shiftedValue; i < nValues; ++i) {\n        shiftedValue = data[i] - shift;\n        if (i === 0) {\n            sums.push(shiftedValue);\n            sumsOfSquares.push(shiftedValue * shiftedValue);\n        } else {\n            sums.push(sums[i - 1] + shiftedValue);\n            sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n        }\n\n        // Initialize for cluster = 0\n        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n        backtrackMatrix[0][i] = 0;\n    }\n\n    // Initialize the rest of the columns\n    var iMin;\n    for (var cluster = 1; cluster < matrix.length; ++cluster) {\n        if (cluster < matrix.length - 1) {\n            iMin = cluster;\n        } else {\n            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n            iMin = nValues - 1;\n        }\n\n        fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n    }\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(x/*: Array<number> */, nClusters/*: number */)/*: Array<Array<number>> */ {\n\n    if (nClusters > x.length) {\n        throw new Error('cannot generate more classes than there are data values');\n    }\n\n    var sorted = numericSort(x),\n        // we'll use this as the maximum number of clusters\n        uniqueCount = uniqueCountSorted(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n        return [sorted];\n    }\n\n    // named 'S' originally\n    var matrix = makeMatrix(nClusters, sorted.length),\n        // named 'J' originally\n        backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n    fillMatrices(sorted, matrix, backtrackMatrix);\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    var clusters = [],\n        clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\n        var clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n        // fill the cluster from the sorted input by taking a slice of the\n        // array. the backtrack matrix makes this easy - it stores the\n        // indexes where the cluster should start and end.\n        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n        if (cluster > 0) {\n            clusterRight = clusterLeft - 1;\n        }\n    }\n\n    return clusters;\n}\n\nmodule.exports = ckmeans;\n","/* @flow */\n'use strict';\n/**\n * Implementation of Combinations\n * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.\n * https://en.wikipedia.org/wiki/Combination\n * @param {Array} x any type of data\n * @param {int} k the number of objects in each group (without replacement)\n * @returns {Array<Array>} array of permutations\n * @example\n * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]\n */\n\nfunction combinations(x /*: Array<any> */, k/*: number */) {\n    var i;\n    var subI;\n    var combinationList = [];\n    var subsetCombinations;\n    var next;\n\n    for (i = 0; i < x.length; i++) {\n        if (k === 1) {\n            combinationList.push([x[i]])\n        } else {\n            subsetCombinations = combinations(x.slice( i + 1, x.length ), k - 1);\n            for (subI = 0; subI < subsetCombinations.length; subI++) {\n                next = subsetCombinations[subI];\n                next.unshift(x[i]);\n                combinationList.push(next);\n            }\n        }\n    }\n    return combinationList;\n}\n\nmodule.exports = combinations;\n","/* @flow */\n'use strict';\n\n/**\n * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement\n * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.\n * 'With replacement' means that a given element can be chosen multiple times.\n * Unlike permutation, order doesn't matter for combinations.\n * \n * @param {Array} x any type of data\n * @param {int} k the number of objects in each group (without replacement)\n * @returns {Array<Array>} array of permutations\n * @example\n * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]\n */\nfunction combinationsReplacement(\n    x /*: Array<any> */,\n    k /*: number */) {\n\n    var combinationList = [];\n\n    for (var i = 0; i < x.length; i++) {\n        if (k === 1) {\n            // If we're requested to find only one element, we don't need\n            // to recurse: just push `x[i]` onto the list of combinations.\n            combinationList.push([x[i]])\n        } else {\n            // Otherwise, recursively find combinations, given `k - 1`. Note that\n            // we request `k - 1`, so if you were looking for k=3 combinations, we're\n            // requesting k=2. This -1 gets reversed in the for loop right after this\n            // code, since we concatenate `x[i]` onto the selected combinations,\n            // bringing `k` back up to your requested level.\n            // This recursion may go many levels deep, since it only stops once\n            // k=1.\n            var subsetCombinations = combinationsReplacement(\n                x.slice(i, x.length),\n                k - 1);\n\n            for (var j = 0; j < subsetCombinations.length; j++) {\n                combinationList.push([x[i]]\n                    .concat(subsetCombinations[j]));\n            }\n        }\n    }\n\n    return combinationList;\n}\n\nmodule.exports = combinationsReplacement;\n","'use strict';\n/* @flow */\n\n/**\n * When combining two lists of values for which one already knows the means,\n * one does not have to necessary recompute the mean of the combined lists in\n * linear time. They can instead use this function to compute the combined\n * mean by providing the mean & number of values of the first list and the mean\n * & number of values of the second list.\n *\n * @since 3.0.0\n * @param {number} mean1 mean of the first list\n * @param {number} n1 number of items in the first list\n * @param {number} mean2 mean of the second list\n * @param {number} n2 number of items in the second list\n * @returns {number} the combined mean\n *\n * @example\n * combineMeans(5, 3, 4, 3); // => 4.5\n */\nfunction combineMeans(mean1 /*: number*/, n1/*: number */, mean2 /*: number*/, n2/*: number */)/*: number */ {\n    return (mean1 * n1 + mean2 * n2) / (n1 + n2);\n}\n\nmodule.exports = combineMeans;\n","'use strict';\n/* @flow */\n\nvar combineMeans = require(13)\n\n/**\n * When combining two lists of values for which one already knows the variances,\n * one does not have to necessary recompute the variance of the combined lists\n * in linear time. They can instead use this function to compute the combined\n * variance by providing the variance, mean & number of values of the first list\n * and the variance, mean & number of values of the second list.\n *\n * @since 3.0.0\n * @param {number} variance1 variance of the first list\n * @param {number} mean1 mean of the first list\n * @param {number} n1 number of items in the first list\n * @param {number} variance2 variance of the second list\n * @param {number} mean2 mean of the second list\n * @param {number} n2 number of items in the second list\n * @returns {number} the combined mean\n *\n * @example\n * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12\n */\nfunction combineVariances(\n    variance1 /*: number*/,\n    mean1 /*: number*/,\n    n1/*: number */,\n    variance2 /*: number*/,\n    mean2 /*: number*/,\n    n2/*: number */)/*: number */ {\n\n    var newMean = combineMeans(mean1, n1, mean2, n2);\n\n    return (\n        n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +\n        n2 * (variance2 + Math.pow(mean2 - newMean, 2))\n    ) / (n1 + n2);\n}\n\nmodule.exports = combineVariances;\n","'use strict';\n/* @flow */\n\nvar standardNormalTable = require(60);\n\n/**\n * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**\n *\n * Since probability tables cannot be\n * printed for every normal distribution, as there are an infinite variety\n * of normal distributions, it is common practice to convert a normal to a\n * standard normal and then use the standard normal table to find probabilities.\n *\n * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability\n * instead of looking it up in a table.\n *\n * @param {number} z\n * @returns {number} cumulative standard normal probability\n */\nfunction cumulativeStdNormalProbability(z /*:number */)/*:number */ {\n\n    // Calculate the position of this value.\n    var absZ = Math.abs(z),\n        // Each row begins with a different\n        // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table\n        // corresponds to a range of 0.01 in the input values, so the value is\n        // multiplied by 100.\n        index = Math.min(Math.round(absZ * 100), standardNormalTable.length - 1);\n\n    // The index we calculate must be in the table as a positive value,\n    // but we still pay attention to whether the input is positive\n    // or negative, and flip the output value as a last step.\n    if (z >= 0) {\n        return standardNormalTable[index];\n    } else {\n        // due to floating-point arithmetic, values in the table with\n        // 4 significant figures can nevertheless end up as repeating\n        // fractions when they're computed here.\n        return +(1 - standardNormalTable[index]).toFixed(4);\n    }\n}\n\nmodule.exports = cumulativeStdNormalProbability;\n","'use strict';\n/* @flow */\n\n/**\n * We use `ε`, epsilon, as a stopping criterion when we want to iterate\n * until we're \"close enough\". Epsilon is a very small number: for\n * simple statistics, that number is **0.0001**\n *\n * This is used in calculations like the binomialDistribution, in which\n * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):\n * it progresses until it is close enough.\n *\n * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),\n * where we're trying to find a local minimum of a function's derivative,\n * given by the `fDerivative` method.\n *\n * @example\n * // From calculation, we expect that the local minimum occurs at x=9/4\n * var x_old = 0;\n * // The algorithm starts at x=6\n * var x_new = 6;\n * var stepSize = 0.01;\n *\n * function fDerivative(x) {\n *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);\n * }\n *\n * // The loop runs until the difference between the previous\n * // value and the current value is smaller than epsilon - a rough\n * // meaure of 'close enough'\n * while (Math.abs(x_new - x_old) > ss.epsilon) {\n *   x_old = x_new;\n *   x_new = x_old - stepSize * fDerivative(x_old);\n * }\n *\n * console.log('Local minimum occurs at', x_new);\n */\nvar epsilon = 0.0001;\n\nmodule.exports = epsilon;\n","'use strict';\n/* @flow */\n\nvar max = require(26),\n    min = require(32);\n\n/**\n * Given an array of x, this will find the extent of the\n * x and return an array of breaks that can be used\n * to categorize the x into a number of classes. The\n * returned array will always be 1 longer than the number of\n * classes because it includes the minimum value.\n *\n * @param {Array<number>} x an array of number values\n * @param {number} nClasses number of desired classes\n * @returns {Array<number>} array of class break positions\n * @example\n * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); //= [1, 2.25, 3.5, 4.75, 6]\n */\nfunction equalIntervalBreaks(x/*: Array<number> */, nClasses/*:number*/)/*: Array<number> */ {\n\n    if (x.length < 2) {\n        return x;\n    }\n\n    var theMin = min(x),\n        theMax = max(x); \n\n    // the first break will always be the minimum value\n    // in the xset\n    var breaks = [theMin];\n\n    // The size of each break is the full range of the x\n    // divided by the number of classes requested\n    var breakSize = (theMax - theMin) / nClasses;\n\n    // In the case of nClasses = 1, this loop won't run\n    // and the returned breaks will be [min, max]\n    for (var i = 1; i < nClasses; i++) {\n        breaks.push(breaks[0] + breakSize * i);\n    }\n\n    // the last break will always be the\n    // maximum.\n    breaks.push(theMax);\n\n    return breaks;\n}\n\nmodule.exports = equalIntervalBreaks;\n","'use strict';\n/* @flow */\n\n/**\n * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**\n *\n * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a\n * normal distribution with standard deviation sd is within x of the mean.\n *\n * This function returns a numerical approximation to the exact value.\n *\n * @param {number} x input\n * @return {number} error estimation\n * @example\n * errorFunction(1).toFixed(2); // => '0.84'\n */\nfunction errorFunction(x/*: number */)/*: number */ {\n    var t = 1 / (1 + 0.5 * Math.abs(x));\n    var tau = t * Math.exp(-Math.pow(x, 2) -\n        1.26551223 +\n        1.00002368 * t +\n        0.37409196 * Math.pow(t, 2) +\n        0.09678418 * Math.pow(t, 3) -\n        0.18628806 * Math.pow(t, 4) +\n        0.27886807 * Math.pow(t, 5) -\n        1.13520398 * Math.pow(t, 6) +\n        1.48851587 * Math.pow(t, 7) -\n        0.82215223 * Math.pow(t, 8) +\n        0.17087277 * Math.pow(t, 9));\n    if (x >= 0) {\n        return 1 - tau;\n    } else {\n        return tau - 1;\n    }\n}\n\nmodule.exports = errorFunction;\n","'use strict';\n/* @flow */\n\n/**\n * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive\n * integers less than or equal to n. Often factorial is implemented\n * recursively, but this iterative approach is significantly faster\n * and simpler.\n *\n * @param {number} n input, must be an integer number 1 or greater\n * @returns {number} factorial: n!\n * @throws {Error} if n is less than 0 or not an integer\n * @example\n * factorial(5); // => 120\n */\nfunction factorial(n /*: number */)/*: number */ {\n\n    // factorial is mathematically undefined for negative numbers\n    if (n < 0) {\n        throw new Error('factorial requires a non-negative value');\n    }\n\n    if (Math.floor(n) !== n) {\n        throw new Error('factorial requires an integer input');\n    }\n\n    // typically you'll expand the factorial function going down, like\n    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,\n    // counting from 2 up to the number in question, and since anything\n    // multiplied by 1 is itself, the loop only needs to start at 2.\n    var accumulator = 1;\n    for (var i = 2; i <= n; i++) {\n        // for each number up to and including the number `n`, multiply\n        // the accumulator my that number.\n        accumulator *= i;\n    }\n    return accumulator;\n}\n\nmodule.exports = factorial;\n","'use strict';\n/* @flow */\n\n/**\n * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is\n * a mean function that is more useful for numbers in different\n * ranges.\n *\n * This is the nth root of the input numbers multiplied by each other.\n *\n * The geometric mean is often useful for\n * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given\n * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple\n * mean will incorrectly estimate an average growth rate, whereas a geometric\n * mean will correctly estimate a growth rate that, over those years,\n * will yield the same end value.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x sample of one or more data points\n * @returns {number} geometric mean\n * @throws {Error} if x is empty\n * @throws {Error} if x contains a negative number\n * @example\n * var growthRates = [1.80, 1.166666, 1.428571];\n * var averageGrowth = geometricMean(growthRates);\n * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];\n * var startingValue = 10;\n * var startingValueMean = 10;\n * growthRates.forEach(function(rate) {\n *   startingValue *= rate;\n * });\n * averageGrowthRates.forEach(function(rate) {\n *   startingValueMean *= rate;\n * });\n * startingValueMean === startingValue;\n */\nfunction geometricMean(x /*: Array<number> */) {\n    // The mean of no numbers is null\n    if (x.length === 0) {\n        throw new Error('geometricMean requires at least one data point');\n    }\n\n    // the starting value.\n    var value = 1;\n\n    for (var i = 0; i < x.length; i++) {\n        // the geometric mean is only valid for positive numbers\n        if (x[i] <= 0) {\n            throw new Error('geometricMean requires only positive numbers as input');\n        }\n\n        // repeatedly multiply the value by each number\n        value *= x[i];\n    }\n\n    return Math.pow(value, 1 / x.length);\n}\n\nmodule.exports = geometricMean;\n","'use strict';\n/* @flow */\n\n/**\n * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is\n * a mean function typically used to find the average of rates.\n * This mean is calculated by taking the reciprocal of the arithmetic mean\n * of the reciprocals of the input numbers.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x sample of one or more data points\n * @returns {number} harmonic mean\n * @throws {Error} if x is empty\n * @throws {Error} if x contains a negative number\n * @example\n * harmonicMean([2, 3]).toFixed(2) // => '2.40'\n */\nfunction harmonicMean(x /*: Array<number> */) {\n    // The mean of no numbers is null\n    if (x.length === 0) {\n        throw new Error('harmonicMean requires at least one data point');\n    }\n\n    var reciprocalSum = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        // the harmonic mean is only valid for positive numbers\n        if (x[i] <= 0) {\n            throw new Error('harmonicMean requires only positive numbers as input');\n        }\n\n        reciprocalSum += 1 / x[i];\n    }\n\n    // divide n by the the reciprocal sum\n    return x.length / reciprocalSum;\n}\n\nmodule.exports = harmonicMean;\n","'use strict';\n/* @flow */\n\nvar quantile = require(43);\n\n/**\n * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is\n * a measure of statistical dispersion, or how scattered, spread, or\n * concentrated a distribution is. It's computed as the difference between\n * the third quartile and first quartile.\n *\n * @param {Array<number>} x sample of one or more numbers\n * @returns {number} interquartile range: the span between lower and upper quartile,\n * 0.25 and 0.75\n * @example\n * interquartileRange([0, 1, 2, 3]); // => 2\n */\nfunction interquartileRange(x/*: Array<number> */) {\n    // Interquartile range is the span between the upper quartile,\n    // at `0.75`, and lower quartile, `0.25`\n    var q1 = quantile(x, 0.75),\n        q2 = quantile(x, 0.25);\n\n    if (typeof q1 === 'number' && typeof q2 === 'number') {\n        return q1 - q2;\n    }\n}\n\nmodule.exports = interquartileRange;\n","'use strict';\n/* @flow */\n\n/**\n * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)\n * returns a numerical approximation to the value that would have caused\n * `errorFunction()` to return x.\n *\n * @param {number} x value of error function\n * @returns {number} estimated inverted value\n */\nfunction inverseErrorFunction(x/*: number */)/*: number */ {\n    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));\n\n    var inv = Math.sqrt(Math.sqrt(\n        Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -\n        Math.log(1 - x * x) / a) -\n        (2 / (Math.PI * a) + Math.log(1 - x * x) / 2));\n\n    if (x >= 0) {\n        return inv;\n    } else {\n        return -inv;\n    }\n}\n\nmodule.exports = inverseErrorFunction;\n","'use strict';\n/* @flow */\n\n/**\n * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)\n * is a simple way to find a fitted line\n * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line\n * using the least sum of squares.\n *\n * @param {Array<Array<number>>} data an array of two-element of arrays,\n * like `[[0, 1], [2, 3]]`\n * @returns {Object} object containing slope and intersect of regression line\n * @example\n * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }\n */\nfunction linearRegression(data/*: Array<Array<number>> */)/*: { m: number, b: number } */ {\n\n    var m, b;\n\n    // Store data length in a local variable to reduce\n    // repeated object property lookups\n    var dataLength = data.length;\n\n    //if there's only one point, arbitrarily choose a slope of 0\n    //and a y-intercept of whatever the y of the initial point is\n    if (dataLength === 1) {\n        m = 0;\n        b = data[0][1];\n    } else {\n        // Initialize our sums and scope the `m` and `b`\n        // variables that define the line.\n        var sumX = 0, sumY = 0,\n            sumXX = 0, sumXY = 0;\n\n        // Use local variables to grab point values\n        // with minimal object property lookups\n        var point, x, y;\n\n        // Gather the sum of all x values, the sum of all\n        // y values, and the sum of x^2 and (x*y) for each\n        // value.\n        //\n        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy\n        for (var i = 0; i < dataLength; i++) {\n            point = data[i];\n            x = point[0];\n            y = point[1];\n\n            sumX += x;\n            sumY += y;\n\n            sumXX += x * x;\n            sumXY += x * y;\n        }\n\n        // `m` is the slope of the regression line\n        m = ((dataLength * sumXY) - (sumX * sumY)) /\n            ((dataLength * sumXX) - (sumX * sumX));\n\n        // `b` is the y-intercept of the line.\n        b = (sumY / dataLength) - ((m * sumX) / dataLength);\n    }\n\n    // Return both values as an object.\n    return {\n        m: m,\n        b: b\n    };\n}\n\n\nmodule.exports = linearRegression;\n","'use strict';\n/* @flow */\n\n/**\n * Given the output of `linearRegression`: an object\n * with `m` and `b` values indicating slope and intercept,\n * respectively, generate a line function that translates\n * x values into y values.\n *\n * @param {Object} mb object with `m` and `b` members, representing\n * slope and intersect of desired line\n * @returns {Function} method that computes y-value at any given\n * x-value on the line.\n * @example\n * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));\n * l(0) // = 0\n * l(2) // = 2\n * linearRegressionLine({ b: 0, m: 1 })(1); // => 1\n * linearRegressionLine({ b: 1, m: 1 })(1); // => 2\n */\nfunction linearRegressionLine(mb/*: { b: number, m: number }*/)/*: Function */ {\n    // Return a function that computes a `y` value for each\n    // x value it is given, based on the values of `b` and `a`\n    // that we just computed.\n    return function(x) {\n        return mb.b + (mb.m * x);\n    };\n}\n\nmodule.exports = linearRegressionLine;\n","'use strict';\n/* @flow */\n\n/**\n * This computes the maximum number in an array.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x sample of one or more data points\n * @returns {number} maximum value\n * @throws {Error} if the the length of x is less than one\n * @example\n * max([1, 2, 3, 4]);\n * // => 4\n */\nfunction max(x /*: Array<number> */) /*:number*/ {\n\n    if (x.length === 0) {\n        throw new Error('max requires at least one data point');\n    }\n\n    var value = x[0];\n    for (var i = 1; i < x.length; i++) {\n        // On the first iteration of this loop, max is\n        // undefined and is thus made the maximum element in the array\n        if (x[i] > value) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = max;\n","'use strict';\n/* @flow */\n\n/**\n * The maximum is the highest number in the array. With a sorted array,\n * the last element in the array is always the largest, so this calculation\n * can be done in one step, or constant time.\n *\n * @param {Array<number>} x input\n * @returns {number} maximum value\n * @example\n * maxSorted([-100, -10, 1, 2, 5]); // => 5\n */\nfunction maxSorted(x /*: Array<number> */)/*:number*/ {\n    return x[x.length - 1];\n}\n\nmodule.exports = maxSorted;\n","'use strict';\n/* @flow */\n\nvar sum = require(62);\n\n/**\n * The mean, _also known as average_,\n * is the sum of all values over the number of values.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x sample of one or more data points\n * @throws {Error} if the the length of x is less than one\n * @returns {number} mean\n * @example\n * mean([0, 10]); // => 5\n */\nfunction mean(x /*: Array<number> */)/*:number*/ {\n    // The mean of no numbers is null\n    if (x.length === 0) {\n        throw new Error('mean requires at least one data point');\n    }\n\n    return sum(x) / x.length;\n}\n\nmodule.exports = mean;\n","'use strict';\n/* @flow */\n\nvar quantile = require(43);\n\n/**\n * The [median](http://en.wikipedia.org/wiki/Median) is\n * the middle number of a list. This is often a good indicator of 'the middle'\n * when there are outliers that skew the `mean()` value.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * The median isn't necessarily one of the elements in the list: the value\n * can be the average of two elements if the list has an even length\n * and the two central values are different.\n *\n * @param {Array<number>} x input\n * @returns {number} median value\n * @example\n * median([10, 2, 5, 100, 2, 1]); // => 3.5\n */\nfunction median(x /*: Array<number> */)/*:number*/ {\n    return +quantile(x, 0.5);\n}\n\nmodule.exports = median;\n","'use strict';\n/* @flow */\n\nvar median = require(29);\n\n/**\n * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is\n * a robust measure of statistical\n * dispersion. It is more resilient to outliers than the standard deviation.\n *\n * @param {Array<number>} x input array\n * @returns {number} median absolute deviation\n * @example\n * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1\n */\nfunction medianAbsoluteDeviation(x /*: Array<number> */) {\n    // The mad of nothing is null\n    var medianValue = median(x),\n        medianAbsoluteDeviations = [];\n\n    // Make a list of absolute deviations from the median\n    for (var i = 0; i < x.length; i++) {\n        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));\n    }\n\n    // Find the median value of that list\n    return median(medianAbsoluteDeviations);\n}\n\nmodule.exports = medianAbsoluteDeviation;\n","'use strict';\n/* @flow */\n\nvar quantileSorted = require(44);\n\n/**\n * The [median](http://en.wikipedia.org/wiki/Median) is\n * the middle number of a list. This is often a good indicator of 'the middle'\n * when there are outliers that skew the `mean()` value.\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * The median isn't necessarily one of the elements in the list: the value\n * can be the average of two elements if the list has an even length\n * and the two central values are different.\n *\n * @param {Array<number>} sorted input\n * @returns {number} median value\n * @example\n * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5\n */\nfunction medianSorted(sorted /*: Array<number> */)/*:number*/ {\n    return quantileSorted(sorted, 0.5);\n}\n\nmodule.exports = medianSorted;\n","'use strict';\n/* @flow */\n\n/**\n * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x sample of one or more data points\n * @throws {Error} if the the length of x is less than one\n * @returns {number} minimum value\n * @example\n * min([1, 5, -10, 100, 2]); // => -10\n */\nfunction min(x /*: Array<number> */)/*:number*/ {\n\n    if (x.length === 0) {\n        throw new Error('min requires at least one data point');\n    }\n\n    var value = x[0];\n    for (var i = 1; i < x.length; i++) {\n        // On the first iteration of this loop, min is\n        // undefined and is thus made the minimum element in the array\n        if (x[i] < value) {\n            value = x[i];\n        }\n    }\n    return value;\n}\n\nmodule.exports = min;\n","'use strict';\n/* @flow */\n\n/**\n * The minimum is the lowest number in the array. With a sorted array,\n * the first element in the array is always the smallest, so this calculation\n * can be done in one step, or constant time.\n *\n * @param {Array<number>} x input\n * @returns {number} minimum value\n * @example\n * minSorted([-100, -10, 1, 2, 5]); // => -100\n */\nfunction minSorted(x /*: Array<number> */)/*:number*/ {\n    return x[0];\n}\n\nmodule.exports = minSorted;\n","'use strict';\n/* @flow */\n\nvar numericSort = require(37),\n    modeSorted = require(36);\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs on `O(nlog(n))` because it needs to sort the array internally\n * before running an `O(n)` search to find the mode.\n *\n * @param {Array<number>} x input\n * @returns {number} mode\n * @example\n * mode([0, 0, 1]); // => 0\n */\nfunction mode(x /*: Array<number> */)/*:number*/ {\n    // Sorting the array lets us iterate through it below and be sure\n    // that every time we see a new number it's new and we'll never\n    // see the same number twice\n    return modeSorted(numericSort(x));\n}\n\nmodule.exports = mode;\n","'use strict';\n/* @flow */\n/* globals Map: false */\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * modeFast uses a Map object to keep track of the mode, instead of the approach\n * used with `mode`, a sorted array. As a result, it is faster\n * than `mode` and supports any data type that can be compared with `==`.\n * It also requires a\n * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),\n * and will throw an error if Map is not available.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * @param {Array<*>} x a sample of one or more data points\n * @returns {?*} mode\n * @throws {ReferenceError} if the JavaScript environment doesn't support Map\n * @throws {Error} if x is empty\n * @example\n * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'\n */\nfunction modeFast/*::<T>*/(x /*: Array<T> */)/*: ?T */ {\n\n    // This index will reflect the incidence of different values, indexing\n    // them like\n    // { value: count }\n    var index = new Map();\n\n    // A running `mode` and the number of times it has been encountered.\n    var mode;\n    var modeCount = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        var newCount = index.get(x[i]);\n        if (newCount === undefined) {\n            newCount = 1;\n        } else {\n            newCount++;\n        }\n        if (newCount > modeCount) {\n            mode = x[i];\n            modeCount = newCount;\n        }\n        index.set(x[i], newCount);\n    }\n\n    if (modeCount === 0) {\n        throw new Error('mode requires at last one data point');\n    }\n\n    return mode;\n}\n\nmodule.exports = modeFast;\n","'use strict';\n/* @flow */\n\n/**\n * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs in `O(n)` because the input is sorted.\n *\n * @param {Array<number>} sorted a sample of one or more data points\n * @returns {number} mode\n * @throws {Error} if sorted is empty\n * @example\n * modeSorted([0, 0, 1]); // => 0\n */\nfunction modeSorted(sorted /*: Array<number> */)/*:number*/ {\n\n    // Handle edge cases:\n    // The mode of an empty list is undefined\n    if (sorted.length === 0) {\n        throw new Error('mode requires at least one data point');\n    } else if (sorted.length === 1) {\n        return sorted[0];\n    }\n\n    // This assumes it is dealing with an array of size > 1, since size\n    // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n    // array.\n    var last = sorted[0],\n        // store the mode as we find new modes\n        value = NaN,\n        // store how many times we've seen the mode\n        maxSeen = 0,\n        // how many times the current candidate for the mode\n        // has been seen\n        seenThis = 1;\n\n    // end at sorted.length + 1 to fix the case in which the mode is\n    // the highest number that occurs in the sequence. the last iteration\n    // compares sorted[i], which is undefined, to the highest number\n    // in the series\n    for (var i = 1; i < sorted.length + 1; i++) {\n        // we're seeing a new number pass by\n        if (sorted[i] !== last) {\n            // the last number is the new mode since we saw it more\n            // often than the old one\n            if (seenThis > maxSeen) {\n                maxSeen = seenThis;\n                value = last;\n            }\n            seenThis = 1;\n            last = sorted[i];\n        // if this isn't a new number, it's one more occurrence of\n        // the potential mode\n        } else { seenThis++; }\n    }\n    return value;\n}\n\nmodule.exports = modeSorted;\n","'use strict';\n/* @flow */\n\n/**\n * Sort an array of numbers by their numeric value, ensuring that the\n * array is not changed in place.\n *\n * This is necessary because the default behavior of .sort\n * in JavaScript is to sort arrays as string values\n *\n *     [1, 10, 12, 102, 20].sort()\n *     // output\n *     [1, 10, 102, 12, 20]\n *\n * @param {Array<number>} x input array\n * @return {Array<number>} sorted array\n * @private\n * @example\n * numericSort([3, 2, 1]) // => [1, 2, 3]\n */\nfunction numericSort(x /*: Array<number> */) /*: Array<number> */ {\n    return x\n        // ensure the array is not changed in-place\n        .slice()\n        // comparator function that treats input as numeric\n        .sort(function(a, b) {\n            return a - b;\n        });\n}\n\nmodule.exports = numericSort;\n","'use strict';\n/* @flow */\n\n/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nfunction PerceptronModel() {\n    // The weights, or coefficients of the model;\n    // weights are only populated when training with data.\n    this.weights = [];\n    // The bias term, or intercept; it is also a weight but\n    // it's stored separately for convenience as it is always\n    // multiplied by one.\n    this.bias = 0;\n}\n\n/**\n * **Predict**: Use an array of features with the weight array and bias\n * to predict whether an example is labeled 0 or 1.\n *\n * @param {Array<number>} features an array of features as numbers\n * @returns {number} 1 if the score is over 0, otherwise 0\n */\nPerceptronModel.prototype.predict = function(features) {\n\n    // Only predict if previously trained\n    // on the same size feature array(s).\n    if (features.length !== this.weights.length) { return null; }\n\n    // Calculate the sum of features times weights,\n    // with the bias added (implicitly times one).\n    var score = 0;\n    for (var i = 0; i < this.weights.length; i++) {\n        score += this.weights[i] * features[i];\n    }\n    score += this.bias;\n\n    // Classify as 1 if the score is over 0, otherwise 0.\n    if (score > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * **Train** the classifier with a new example, which is\n * a numeric array of features and a 0 or 1 label.\n *\n * @param {Array<number>} features an array of features as numbers\n * @param {number} label either 0 or 1\n * @returns {PerceptronModel} this\n */\nPerceptronModel.prototype.train = function(features, label) {\n    // Require that only labels of 0 or 1 are considered.\n    if (label !== 0 && label !== 1) { return null; }\n    // The length of the feature array determines\n    // the length of the weight array.\n    // The perceptron will continue learning as long as\n    // it keeps seeing feature arrays of the same length.\n    // When it sees a new data shape, it initializes.\n    if (features.length !== this.weights.length) {\n        this.weights = features;\n        this.bias = 1;\n    }\n    // Make a prediction based on current weights.\n    var prediction = this.predict(features);\n    // Update the weights if the prediction is wrong.\n    if (prediction !== label) {\n        var gradient = label - prediction;\n        for (var i = 0; i < this.weights.length; i++) {\n            this.weights[i] += gradient * features[i];\n        }\n        this.bias += gradient;\n    }\n    return this;\n};\n\nmodule.exports = PerceptronModel;\n","/* @flow */\n\n'use strict';\n\n/**\n * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)\n * for generating permutations.\n *\n * @param {Array} elements any type of data\n * @returns {Array<Array>} array of permutations\n */\nfunction permutationsHeap/*:: <T> */(elements /*: Array<T> */)/*: Array<Array<T>> */ {\n    var indexes = new Array(elements.length);\n    var permutations = [elements.slice()];\n\n    for (var i = 0; i < elements.length; i++) {\n        indexes[i] = 0;\n    }\n\n    for (i = 0; i < elements.length;) {\n        if (indexes[i] < i) {\n\n            // At odd indexes, swap from indexes[i] instead\n            // of from the beginning of the array\n            var swapFrom = 0;\n            if (i % 2 !== 0) {\n                swapFrom = indexes[i];\n            }\n\n            // swap between swapFrom and i, using\n            // a temporary variable as storage.\n            var temp = elements[swapFrom];\n            elements[swapFrom] = elements[i];\n            elements[i] = temp;\n\n            permutations.push(elements.slice());\n            indexes[i]++;\n            i = 0;\n\n        } else {\n            indexes[i] = 0;\n            i++;\n        }\n    }\n\n    return permutations;\n}\n\nmodule.exports = permutationsHeap;\n","'use strict';\n/* @flow */\n\nvar epsilon = require(16);\n\n/**\n * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)\n * is a discrete probability distribution that expresses the probability\n * of a given number of events occurring in a fixed interval of time\n * and/or space if these events occur with a known average rate and\n * independently of the time since the last event.\n *\n * The Poisson Distribution is characterized by the strictly positive\n * mean arrival or occurrence rate, `λ`.\n *\n * @param {number} lambda location poisson distribution\n * @returns {number[]} values of poisson distribution at that point\n */\nfunction poissonDistribution(lambda/*: number */) /*: ?number[] */ {\n    // Check that lambda is strictly positive\n    if (lambda <= 0) { return undefined; }\n\n    // our current place in the distribution\n    var x = 0,\n        // and we keep track of the current cumulative probability, in\n        // order to know when to stop calculating chances.\n        cumulativeProbability = 0,\n        // the calculated cells to be returned\n        cells = [],\n        factorialX = 1;\n\n    // This algorithm iterates through each potential outcome,\n    // until the `cumulativeProbability` is very close to 1, at\n    // which point we've defined the vast majority of outcomes\n    do {\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;\n        cumulativeProbability += cells[x];\n        x++;\n        factorialX *= x;\n    // when the cumulativeProbability is nearly 1, we've calculated\n    // the useful range of this distribution\n    } while (cumulativeProbability < 1 - epsilon);\n\n    return cells;\n}\n\nmodule.exports = poissonDistribution;\n","'use strict';\n/* @flow */\n\nvar epsilon = require(16);\nvar inverseErrorFunction = require(23);\n\n/**\n * The [Probit](http://en.wikipedia.org/wiki/Probit)\n * is the inverse of cumulativeStdNormalProbability(),\n * and is also known as the normal quantile function.\n *\n * It returns the number of standard deviations from the mean\n * where the p'th quantile of values can be found in a normal distribution.\n * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are\n * normally found within 1 standard deviation above or below the mean.\n *\n * @param {number} p\n * @returns {number} probit\n */\nfunction probit(p /*: number */)/*: number */ {\n    if (p === 0) {\n        p = epsilon;\n    } else if (p >= 1) {\n        p = 1 - epsilon;\n    }\n    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);\n}\n\nmodule.exports = probit;\n","'use strict';\n/* @flow */\n\n/**\n * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array\n * is the result of multiplying all numbers together, starting using one as the multiplicative identity.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @return {number} product of all input numbers\n * @example\n * product([1, 2, 3, 4]); // => 24\n */\nfunction product(x/*: Array<number> */)/*: number */ {\n    var value = 1;\n    for (var i = 0; i < x.length; i++) {\n        value *= x[i];\n    }\n    return value;\n}\n\nmodule.exports = product;\n","'use strict';\n/* @flow */\n\nvar quantileSorted = require(44);\nvar quickselect = require(45);\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} x sample of one or more numbers\n * @param {number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantile(x /*: Array<number> */, p /*: Array<number> | number */) {\n    var copy = x.slice();\n\n    if (Array.isArray(p)) {\n        // rearrange elements so that each element corresponding to a requested\n        // quantile is on a place it would be if the array was fully sorted\n        multiQuantileSelect(copy, p);\n        // Initialize the result array\n        var results = [];\n        // For each requested quantile\n        for (var i = 0; i < p.length; i++) {\n            results[i] = quantileSorted(copy, p[i]);\n        }\n        return results;\n    } else {\n        var idx = quantileIndex(copy.length, p);\n        quantileSelect(copy, idx, 0, copy.length - 1);\n        return quantileSorted(copy, p);\n    }\n}\n\nfunction quantileSelect(arr, k, left, right) {\n    if (k % 1 === 0) {\n        quickselect(arr, k, left, right);\n    } else {\n        k = Math.floor(k);\n        quickselect(arr, k, left, right);\n        quickselect(arr, k + 1, k + 1, right);\n    }\n}\n\nfunction multiQuantileSelect(arr, p) {\n    var indices = [0];\n    for (var i = 0; i < p.length; i++) {\n        indices.push(quantileIndex(arr.length, p[i]));\n    }\n    indices.push(arr.length - 1);\n    indices.sort(compare);\n\n    var stack = [0, indices.length - 1];\n\n    while (stack.length) {\n        var r = Math.ceil(stack.pop());\n        var l = Math.floor(stack.pop());\n        if (r - l <= 1) continue;\n\n        var m = Math.floor((l + r) / 2);\n        quantileSelect(arr, indices[m], indices[l], indices[r]);\n\n        stack.push(l, m, m, r);\n    }\n}\n\nfunction compare(a, b) {\n    return a - b;\n}\n\nfunction quantileIndex(len /*: number */, p /*: number */)/*:number*/ {\n    var idx = len * p;\n    if (p === 1) {\n        // If p is 1, directly return the last index\n        return len - 1;\n    } else if (p === 0) {\n        // If p is 0, directly return the first index\n        return 0;\n    } else if (idx % 1 !== 0) {\n        // If index is not integer, return the next index in array\n        return Math.ceil(idx) - 1;\n    } else if (len % 2 === 0) {\n        // If the list has even-length, we'll return the middle of two indices\n        // around quantile to indicate that we need an average value of the two\n        return idx - 0.5;\n    } else {\n        // Finally, in the simple case of an integer index\n        // with an odd-length list, return the index\n        return idx;\n    }\n}\n\nmodule.exports = quantile;\n","'use strict';\n/* @flow */\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} x sample of one or more data points\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @throws {Error} if p ix outside of the range from 0 to 1\n * @throws {Error} if x is empty\n * @example\n * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantileSorted(x /*: Array<number> */, p /*: number */)/*:number*/ {\n    var idx = x.length * p;\n    if (x.length === 0) {\n        throw new Error('quantile requires at least one data point.');\n    } else if (p < 0 || p > 1) {\n        throw new Error('quantiles must be between 0 and 1');\n    } else if (p === 1) {\n        // If p is 1, directly return the last element\n        return x[x.length - 1];\n    } else if (p === 0) {\n        // If p is 0, directly return the first element\n        return x[0];\n    } else if (idx % 1 !== 0) {\n        // If p is not integer, return the next element in array\n        return x[Math.ceil(idx) - 1];\n    } else if (x.length % 2 === 0) {\n        // If the list has even-length, we'll take the average of this number\n        // and the next value, if there is one\n        return (x[idx - 1] + x[idx]) / 2;\n    } else {\n        // Finally, in the simple case of an integer value\n        // with an odd-length list, return the x value at the index.\n        return x[idx];\n    }\n}\n\nmodule.exports = quantileSorted;\n","'use strict';\n/* @flow */\n\nmodule.exports = quickselect;\n\n/**\n * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.\n * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.\n *\n * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm\n *\n * @private\n * @param {Array<number>} arr input array\n * @param {number} k pivot index\n * @param {number} left left index\n * @param {number} right right index\n * @returns {undefined}\n * @example\n * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];\n * quickselect(arr, 8);\n * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]\n */\nfunction quickselect(arr /*: Array<number> */, k /*: number */, left /*: number */, right /*: number */) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n\n    while (right > left) {\n        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);\n            if (m - n / 2 < 0) sd *= -1;\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (arr[right] > t) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (arr[i] < t) i++;\n            while (arr[j] > t) j--;\n        }\n\n        if (arr[left] === t) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","'use strict';\n/* @flow */\n\n/**\n * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)\n * value of data compared with a function `f`\n * is the sum of the squared differences between the prediction\n * and the actual value.\n *\n * @param {Array<Array<number>>} x input data: this should be doubly-nested\n * @param {Function} func function called on `[i][0]` values within the dataset\n * @returns {number} r-squared value\n * @example\n * var samples = [[0, 0], [1, 1]];\n * var regressionLine = linearRegressionLine(linearRegression(samples));\n * rSquared(samples, regressionLine); // = 1 this line is a perfect fit\n */\nfunction rSquared(x /*: Array<Array<number>> */, func /*: Function */) /*: number */ {\n    if (x.length < 2) { return 1; }\n\n    // Compute the average y value for the actual\n    // data set in order to compute the\n    // _total sum of squares_\n    var sum = 0, average;\n    for (var i = 0; i < x.length; i++) {\n        sum += x[i][1];\n    }\n    average = sum / x.length;\n\n    // Compute the total sum of squares - the\n    // squared difference between each point\n    // and the average of all points.\n    var sumOfSquares = 0;\n    for (var j = 0; j < x.length; j++) {\n        sumOfSquares += Math.pow(average - x[j][1], 2);\n    }\n\n    // Finally estimate the error: the squared\n    // difference between the estimate and the actual data\n    // value at each point.\n    var err = 0;\n    for (var k = 0; k < x.length; k++) {\n        err += Math.pow(x[k][1] - func(x[k][0]), 2);\n    }\n\n    // As the error grows larger, its ratio to the\n    // sum of squares increases and the r squared\n    // value grows lower.\n    return 1 - err / sumOfSquares;\n}\n\nmodule.exports = rSquared;\n","'use strict';\n/* @flow */\n\n/**\n * The Root Mean Square (RMS) is\n * a mean function used as a measure of the magnitude of a set\n * of numbers, regardless of their sign.\n * This is the square root of the mean of the squares of the\n * input numbers.\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x a sample of one or more data points\n * @returns {number} root mean square\n * @throws {Error} if x is empty\n * @example\n * rootMeanSquare([-1, 1, -1, 1]); // => 1\n */\nfunction rootMeanSquare(x /*: Array<number> */)/*:number*/ {\n    if (x.length === 0) {\n        throw new Error('rootMeanSquare requires at least one data point');\n    }\n\n    var sumOfSquares = 0;\n    for (var i = 0; i < x.length; i++) {\n        sumOfSquares += Math.pow(x[i], 2);\n    }\n\n    return Math.sqrt(sumOfSquares / x.length);\n}\n\nmodule.exports = rootMeanSquare;\n","'use strict';\n/* @flow */\n\nvar shuffle = require(56);\n\n/**\n * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)\n * from a given array of `n` elements.\n *\n * The sampled values will be in any order, not necessarily the order\n * they appear in the input.\n *\n * @param {Array<any>} x input array. can contain any type\n * @param {number} n count of how many elements to take\n * @param {Function} [randomSource=Math.random] an optional entropy source that\n * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)\n * @return {Array} subset of n elements in original array\n * @example\n * var values = [1, 2, 4, 5, 6, 7, 8, 9];\n * sample(values, 3); // returns 3 random values, like [2, 5, 8];\n */\nfunction sample/*:: <T> */(\n    x /*: Array<T> */,\n    n /*: number */,\n    randomSource /*: Function */) /*: Array<T> */ {\n    // shuffle the original array using a fisher-yates shuffle\n    var shuffled = shuffle(x, randomSource);\n\n    // and then return a subset of it - the first `n` elements.\n    return shuffled.slice(0, n);\n}\n\nmodule.exports = sample;\n","'use strict';\n/* @flow */\n\nvar sampleCovariance = require(50);\nvar sampleStandardDeviation = require(53);\n\n/**\n * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is\n * a measure of how correlated two datasets are, between -1 and 1\n *\n * @param {Array<number>} x first input\n * @param {Array<number>} y second input\n * @returns {number} sample correlation\n * @example\n * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);\n * // => '0.69'\n */\nfunction sampleCorrelation(x/*: Array<number> */, y/*: Array<number> */)/*:number*/ {\n    var cov = sampleCovariance(x, y),\n        xstd = sampleStandardDeviation(x),\n        ystd = sampleStandardDeviation(y);\n\n    return cov / xstd / ystd;\n}\n\nmodule.exports = sampleCorrelation;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\n\n/**\n * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:\n * how much do the two datasets move together?\n * x and y are two datasets, represented as arrays of numbers.\n *\n * @param {Array<number>} x a sample of two or more data points\n * @param {Array<number>} y a sample of two or more data points\n * @throws {Error} if x and y do not have equal lengths\n * @throws {Error} if x or y have length of one or less\n * @returns {number} sample covariance\n * @example\n * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5\n */\nfunction sampleCovariance(x /*:Array<number>*/, y /*:Array<number>*/)/*:number*/ {\n\n    // The two datasets must have the same length which must be more than 1\n    if (x.length !== y.length) {\n        throw new Error('sampleCovariance requires samples with equal lengths');\n    }\n\n    if (x.length < 2) {\n        throw new Error('sampleCovariance requires at least two data points in each sample');\n    }\n\n    // determine the mean of each dataset so that we can judge each\n    // value of the dataset fairly as the difference from the mean. this\n    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance\n    // does not suffer because of the difference in absolute values\n    var xmean = mean(x),\n        ymean = mean(y),\n        sum = 0;\n\n    // for each pair of values, the covariance increases when their\n    // difference from the mean is associated - if both are well above\n    // or if both are well below\n    // the mean, the covariance increases significantly.\n    for (var i = 0; i < x.length; i++) {\n        sum += (x[i] - xmean) * (y[i] - ymean);\n    }\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // the covariance is weighted by the length of the datasets.\n    return sum / besselsCorrection;\n}\n\nmodule.exports = sampleCovariance;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\n\n/**\n * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is\n * a measure of the heaviness of a distribution's tails relative to its\n * variance. The kurtosis value can be positive or negative, or even undefined.\n *\n * Implementation is based on Fisher's excess kurtosis definition and uses \n * unbiased moment estimators. This is the version found in Excel and available \n * in several statistical packages, including SAS and SciPy.\n *\n * @param {Array<number>} x a sample of 4 or more data points\n * @returns {number} sample kurtosis\n * @throws {Error} if x has length less than 4\n * @example\n * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122\n */\nfunction sampleKurtosis(x /*: Array<number> */)/*:number*/ {\n\n    var n = x.length;\n\n    if (n < 4) {\n        throw new Error('sampleKurtosis requires at least four data points');\n    }\n\n    var meanValue = mean(x);\n    var tempValue;\n    var secondCentralMoment = 0;\n    var fourthCentralMoment = 0;\n\n    for (var i = 0; i < n; i++) {\n        tempValue = x[i] - meanValue;\n        secondCentralMoment += tempValue * tempValue;\n        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;\n    }\n\n    return (n - 1) / ((n - 2) * (n - 3)) * \n        (n * (n + 1) * fourthCentralMoment / (secondCentralMoment * secondCentralMoment) - 3 * (n - 1));\n}\n\nmodule.exports = sampleKurtosis;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\n\n/**\n * [Skewness](http://en.wikipedia.org/wiki/Skewness) is\n * a measure of the extent to which a probability distribution of a\n * real-valued random variable \"leans\" to one side of the mean.\n * The skewness value can be positive or negative, or even undefined.\n *\n * Implementation is based on the adjusted Fisher-Pearson standardized\n * moment coefficient, which is the version found in Excel and several\n * statistical packages including Minitab, SAS and SPSS.\n *\n * @since 4.1.0\n * @param {Array<number>} x a sample of 3 or more data points\n * @returns {number} sample skewness\n * @throws {Error} if x has length less than 3\n * @example\n * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365\n */\nfunction sampleSkewness(x /*: Array<number> */)/*:number*/ {\n\n    if (x.length < 3) {\n        throw new Error('sampleSkewness requires at least three data points');\n    }\n\n    var meanValue = mean(x);\n    var tempValue;\n    var sumSquaredDeviations = 0;\n    var sumCubedDeviations = 0;\n\n    for (var i = 0; i < x.length; i++) {\n        tempValue = x[i] - meanValue;\n        sumSquaredDeviations += tempValue * tempValue;\n        sumCubedDeviations += tempValue * tempValue * tempValue;\n    }\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // Find the mean value of that list\n    var theSampleStandardDeviation = Math.sqrt(sumSquaredDeviations / besselsCorrection);\n\n    var n = x.length,\n        cubedS = Math.pow(theSampleStandardDeviation, 3);\n\n    return n * sumCubedDeviations / ((n - 1) * (n - 2) * cubedS);\n}\n\nmodule.exports = sampleSkewness;\n","'use strict';\n/* @flow */\n\nvar sampleVariance = require(54);\n\n/**\n * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)\n * is the square root of the sample variance.\n *\n * @param {Array<number>} x input array\n * @returns {number} sample standard deviation\n * @example\n * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);\n * // => '2.14'\n */\nfunction sampleStandardDeviation(x/*:Array<number>*/)/*:number*/ {\n    // The standard deviation of no numbers is null\n    var sampleVarianceX = sampleVariance(x);\n    return Math.sqrt(sampleVarianceX);\n}\n\nmodule.exports = sampleStandardDeviation;\n","'use strict';\n/* @flow */\n\nvar sumNthPowerDeviations = require(63);\n\n/**\n * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)\n * is the sum of squared deviations from the mean. The sample variance\n * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):\n * instead of dividing the sum of squared deviations by the length of the input,\n * it is divided by the length minus one. This corrects the bias in estimating\n * a value from a set that you don't know if full.\n *\n * References:\n * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)\n *\n * @param {Array<number>} x a sample of two or more data points\n * @throws {Error} if the length of x is less than 2\n * @return {number} sample variance\n * @example\n * sampleVariance([1, 2, 3, 4, 5]); // => 2.5\n */\nfunction sampleVariance(x /*: Array<number> */)/*:number*/ {\n    // The variance of no numbers is null\n    if (x.length < 2) {\n        throw new Error('sampleVariance requires at least two data points');\n    }\n\n    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);\n\n    // this is Bessels' Correction: an adjustment made to sample statistics\n    // that allows for the reduced degree of freedom entailed in calculating\n    // values from samples rather than complete populations.\n    var besselsCorrection = x.length - 1;\n\n    // Find the mean value of that list\n    return sumSquaredDeviationsValue / besselsCorrection;\n}\n\nmodule.exports = sampleVariance;\n","'use strict';\n/* @flow */\n\n/**\n * Sampling with replacement is a type of sampling that allows the same\n * item to be picked out of a population more than once.\n *\n * @param {Array<*>} x an array of any kind of value\n * @param {number} n count of how many elements to take\n * @param {Function} [randomSource=Math.random] an optional entropy source that\n * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)\n * @return {Array} n sampled items from the population\n * @example\n * var sample = sampleWithReplacement([1, 2, 3, 4], 2);\n * sampleWithReplacement; // = [2, 4] or any other random sample of 2 items\n */\nfunction sampleWithReplacement/*::<T>*/(x/*:Array<T>*/,\n    n /*: number */,\n    randomSource/*:Function*/) {\n\n    if (x.length === 0) {\n        return [];\n    }\n\n    // a custom random number source can be provided if you want to use\n    // a fixed seed or another random number generator, like\n    // [random-js](https://www.npmjs.org/package/random-js)\n    randomSource = randomSource || Math.random;\n\n    var length = x.length;\n    var sample = [];\n\n    for (var i = 0; i < n; i++) {\n        var index = Math.floor(randomSource() * length);\n\n        sample.push(x[index]);\n    }\n\n    return sample;\n}\n\nmodule.exports = sampleWithReplacement;\n","'use strict';\n/* @flow */\n\nvar shuffleInPlace = require(57);\n\n/**\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * is a fast way to create a random permutation of a finite set. This is\n * a function around `shuffle_in_place` that adds the guarantee that\n * it will not modify its input.\n *\n * @param {Array} x sample of 0 or more numbers\n * @param {Function} [randomSource=Math.random] an optional entropy source that\n * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)\n * @return {Array} shuffled version of input\n * @example\n * var shuffled = shuffle([1, 2, 3, 4]);\n * shuffled; // = [2, 3, 1, 4] or any other random permutation\n */\nfunction shuffle/*::<T>*/(x/*:Array<T>*/, randomSource/*:Function*/) {\n    // slice the original array so that it is not modified\n    var sample = x.slice();\n\n    // and then shuffle that shallow-copied array, in place\n    return shuffleInPlace(sample.slice(), randomSource);\n}\n\nmodule.exports = shuffle;\n","'use strict';\n/* @flow */\n\n/**\n * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n * in-place - which means that it **will change the order of the original\n * array by reference**.\n *\n * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)\n * of a set.\n *\n * @param {Array} x sample of one or more numbers\n * @param {Function} [randomSource=Math.random] an optional entropy source that\n * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)\n * @returns {Array} x\n * @example\n * var x = [1, 2, 3, 4];\n * shuffleInPlace(x);\n * // x is shuffled to a value like [2, 1, 4, 3]\n */\nfunction shuffleInPlace(x/*:Array<any>*/, randomSource/*:Function*/)/*:Array<any>*/ {\n\n    // a custom random number source can be provided if you want to use\n    // a fixed seed or another random number generator, like\n    // [random-js](https://www.npmjs.org/package/random-js)\n    randomSource = randomSource || Math.random;\n\n    // store the current length of the x to determine\n    // when no elements remain to shuffle.\n    var length = x.length;\n\n    // temporary is used to hold an item when it is being\n    // swapped between indices.\n    var temporary;\n\n    // The index to swap at each stage.\n    var index;\n\n    // While there are still items to shuffle\n    while (length > 0) {\n        // chose a random index within the subset of the array\n        // that is not yet shuffled\n        index = Math.floor(randomSource() * length--);\n\n        // store the value that we'll move temporarily\n        temporary = x[length];\n\n        // swap the value at `x[length]` with `x[index]`\n        x[length] = x[index];\n        x[index] = temporary;\n    }\n\n    return x;\n}\n\nmodule.exports = shuffleInPlace;\n","'use strict';\n/* @flow */\n\n/**\n * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function \n * that extracts the sign of a real number\n * \n * @param {Number} x input value\n * @returns {Number} sign value either 1, 0 or -1\n * @throws {TypeError} if the input argument x is not a number\n * @private\n * \n * @example\n * sign(2); // => 1\n */\nfunction sign(x/*: number */)/*: number */ {\n    if (typeof x === 'number') {\n        if (x < 0) {\n            return -1;\n        } else if (x === 0) {\n            return 0\n        } else {\n            return 1;\n        }\n    } else {\n        throw new TypeError('not a number');\n    }\n}\n\nmodule.exports = sign;\n","'use strict';\n/* @flow */\n\nvar variance = require(68);\n\n/**\n * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n * is the square root of the variance. This is also known as the population\n * standard deviation. It's useful for measuring the amount\n * of variation or dispersion in a set of values.\n *\n * Standard deviation is only appropriate for full-population knowledge: for\n * samples of a population, {@link sampleStandardDeviation} is\n * more appropriate.\n *\n * @param {Array<number>} x input\n * @returns {number} standard deviation\n * @example\n * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4\n * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2\n */\nfunction standardDeviation(x /*: Array<number> */)/*:number*/ {\n    if (x.length === 1) {\n        return 0;\n    }\n    var v = variance(x);\n    return Math.sqrt(v);\n}\n\nmodule.exports = standardDeviation;\n","'use strict';\n/* @flow */\n\nvar SQRT_2PI = Math.sqrt(2 * Math.PI);\n\nfunction cumulativeDistribution(z) {\n    var sum = z,\n        tmp = z;\n\n    // 15 iterations are enough for 4-digit precision\n    for (var i = 1; i < 15; i++) {\n        tmp *= z * z / (2 * i + 1);\n        sum += tmp;\n    }\n    return Math.round((0.5 + (sum / SQRT_2PI) * Math.exp(-z * z / 2)) * 1e4) / 1e4;\n}\n\n/**\n * A standard normal table, also called the unit normal table or Z table,\n * is a mathematical table for the values of Φ (phi), which are the values of\n * the cumulative distribution function of the normal distribution.\n * It is used to find the probability that a statistic is observed below,\n * above, or between values on the standard normal distribution, and by\n * extension, any normal distribution.\n *\n * The probabilities are calculated using the\n * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).\n * The table used is the cumulative, and not cumulative from 0 to mean\n * (even though the latter has 5 digits precision, instead of 4).\n */\nvar standardNormalTable/*: Array<number> */ = [];\n\nfor (var z = 0; z <= 3.09; z += 0.01) {\n    standardNormalTable.push(cumulativeDistribution(z));\n}\n\nmodule.exports = standardNormalTable;\n","'use strict';\n/* @flow */\n\n/**\n * When removing a value from a list, one does not have to necessary\n * recompute the mean of the list in linear time. They can instead use\n * this function to compute the new mean by providing the current mean,\n * the number of elements in the list that produced it and the value to remove.\n *\n * @since 3.0.0\n * @param {number} mean current mean\n * @param {number} n number of items in the list\n * @param {number} value the value to remove\n * @returns {number} the new mean\n *\n * @example\n * subtractFromMean(20.5, 6, 53); // => 14\n */\nfunction subtractFromMean(mean /*: number*/, n/*: number */, value/*: number */)/*: number */ {\n    return ((mean * n) - value) / (n - 1);\n}\n\nmodule.exports = subtractFromMean;\n","'use strict';\n/* @flow */\n\n/**\n * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).\n * This method is an improvement over the classical\n * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n * It aims at computing the sum of a list of numbers while correcting for\n * floating-point errors. Traditionally, sums are calculated as many\n * successive additions, each one with its own floating-point roundoff. These\n * losses in precision add up as the number of numbers increases. This alternative\n * algorithm is more accurate than the simple way of calculating sums by simple\n * addition.\n *\n * This runs on `O(n)`, linear time in respect to the array.\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sum([1, 2, 3]); // => 6\n */\nfunction sum(x/*: Array<number> */)/*: number */ {\n\n    // If the array is empty, we needn't bother computing its sum\n    if (x.length === 0) {\n        return 0;\n    }\n\n    // Initializing the sum as the first number in the array\n    var sum = x[0];\n\n    // Keeping track of the floating-point error correction\n    var correction = 0;\n\n    var transition;\n\n    for (var i = 1; i < x.length; i++) {\n        transition = sum + x[i];\n\n        // Here we need to update the correction in a different fashion\n        // if the new absolute value is greater than the absolute sum\n        if (Math.abs(sum) >= Math.abs(x[i])) {\n            correction += ((sum - transition) + x[i]);\n        }\n        else {\n            correction += ((x[i] - transition) + sum);\n        }\n\n        sum = transition;\n    }\n\n    // Returning the corrected sum\n    return sum + correction;\n}\n\nmodule.exports = sum;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\n\n/**\n * The sum of deviations to the Nth power.\n * When n=2 it's the sum of squared deviations.\n * When n=3 it's the sum of cubed deviations.\n *\n * @param {Array<number>} x\n * @param {number} n power\n * @returns {number} sum of nth power deviations\n * @example\n * var input = [1, 2, 3];\n * // since the variance of a set is the mean squared\n * // deviations, we can calculate that with sumNthPowerDeviations:\n * var variance = sumNthPowerDeviations(input) / input.length;\n */\nfunction sumNthPowerDeviations(x/*: Array<number> */, n/*: number */)/*:number*/ {\n    var meanValue = mean(x),\n        sum = 0,\n        tempValue,\n        i;\n\n    // This is an optimization: when n is 2 (we're computing a number squared),\n    // multiplying the number by itself is significantly faster than using\n    // the Math.pow method.\n    if (n === 2) {\n        for (i = 0; i < x.length; i++) {\n            tempValue = x[i] - meanValue;\n            sum += tempValue * tempValue;\n        }\n    } else {\n        for (i = 0; i < x.length; i++) {\n            sum += Math.pow(x[i] - meanValue, n);\n        }\n    }\n\n    return sum;\n}\n\nmodule.exports = sumNthPowerDeviations;\n","'use strict';\n/* @flow */\n\n/**\n * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array\n * is the result of adding all numbers together, starting from zero.\n *\n * This runs on `O(n)`, linear time in respect to the array\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sumSimple([1, 2, 3]); // => 6\n */\nfunction sumSimple(x/*: Array<number> */)/*: number */ {\n    var value = 0;\n    for (var i = 0; i < x.length; i++) {\n        value += x[i];\n    }\n    return value;\n}\n\nmodule.exports = sumSimple;\n","'use strict';\n/* @flow */\n\nvar standardDeviation = require(59);\nvar mean = require(28);\n\n/**\n * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean\n * of a sample to a known value, x.\n *\n * in this case, we're trying to determine whether the\n * population mean is equal to the value that we know, which is `x`\n * here. usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * @param {Array<number>} x sample of one or more numbers\n * @param {number} expectedValue expected value of the population mean\n * @returns {number} value\n * @example\n * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'\n */\nfunction tTest(x/*: Array<number> */, expectedValue/*: number */)/*:number*/ {\n    // The mean of the sample\n    var sampleMean = mean(x);\n\n    // The standard deviation of the sample\n    var sd = standardDeviation(x);\n\n    // Square root the length of the sample\n    var rootN = Math.sqrt(x.length);\n\n    // returning the t value\n    return (sampleMean - expectedValue) / (sd / rootN);\n}\n\nmodule.exports = tTest;\n","'use strict';\n/* @flow */\n\nvar mean = require(28);\nvar sampleVariance = require(54);\n\n/**\n * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).\n * Tests whether \"mean(X)-mean(Y) = difference\", (\n * in the most common case, we often have `difference == 0` to test if two samples\n * are likely to be taken from populations with the same mean value) with\n * no prior knowledge on standard deviations of both samples\n * other than the fact that they have the same standard deviation.\n *\n * Usually the results here are used to look up a\n * [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n * a certain level of significance, will let you determine that the\n * null hypothesis can or cannot be rejected.\n *\n * `diff` can be omitted if it equals 0.\n *\n * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)\n * a null hypothesis that the two populations that have been sampled into\n * `sampleX` and `sampleY` are equal to each other.\n *\n * @param {Array<number>} sampleX a sample as an array of numbers\n * @param {Array<number>} sampleY a sample as an array of numbers\n * @param {number} [difference=0]\n * @returns {number} test result\n * @example\n * ss.tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); //= -2.1908902300206643\n */\nfunction tTestTwoSample(\n    sampleX/*: Array<number> */,\n    sampleY/*: Array<number> */,\n    difference/*: number */) {\n    var n = sampleX.length,\n        m = sampleY.length;\n\n    // If either sample doesn't actually have any values, we can't\n    // compute this at all, so we return `null`.\n    if (!n || !m) { return null; }\n\n    // default difference (mu) is zero\n    if (!difference) {\n        difference = 0;\n    }\n\n    var meanX = mean(sampleX),\n        meanY = mean(sampleY),\n        sampleVarianceX = sampleVariance(sampleX),\n        sampleVarianceY = sampleVariance(sampleY);\n\n    if (typeof meanX === 'number' &&\n        typeof meanY === 'number' &&\n        typeof sampleVarianceX === 'number' &&\n        typeof sampleVarianceY === 'number') {\n        var weightedVariance = ((n - 1) * sampleVarianceX +\n            (m - 1) * sampleVarianceY) / (n + m - 2);\n\n        return (meanX - meanY - difference) /\n            Math.sqrt(weightedVariance * (1 / n + 1 / m));\n    }\n}\n\nmodule.exports = tTestTwoSample;\n","'use strict';\n/* @flow */\n\n/**\n * For a sorted input, counting the number of unique values\n * is possible in constant time and constant memory. This is\n * a simple implementation of the algorithm.\n *\n * Values are compared with `===`, so objects and non-primitive objects\n * are not handled in any special way.\n *\n * @param {Array<*>} x an array of any kind of value\n * @returns {number} count of unique values\n * @example\n * uniqueCountSorted([1, 2, 3]); // => 3\n * uniqueCountSorted([1, 1, 1]); // => 1\n */\nfunction uniqueCountSorted(x/*: Array<any>*/)/*: number */ {\n    var uniqueValueCount = 0,\n        lastSeenValue;\n    for (var i = 0; i < x.length; i++) {\n        if (i === 0 || x[i] !== lastSeenValue) {\n            lastSeenValue = x[i];\n            uniqueValueCount++;\n        }\n    }\n    return uniqueValueCount;\n}\n\nmodule.exports = uniqueCountSorted;\n","'use strict';\n/* @flow */\n\nvar sumNthPowerDeviations = require(63);\n\n/**\n * The [variance](http://en.wikipedia.org/wiki/Variance)\n * is the sum of squared deviations from the mean.\n *\n * This is an implementation of variance, not sample variance:\n * see the `sampleVariance` method if you want a sample measure.\n *\n * @param {Array<number>} x a population of one or more data points\n * @returns {number} variance: a value greater than or equal to zero.\n * zero indicates that all values are identical.\n * @throws {Error} if x's length is 0\n * @example\n * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665\n */\nfunction variance(x/*: Array<number> */)/*:number*/ {\n    // The variance of no numbers is null\n    if (x.length === 0) {\n        throw new Error('variance requires at least one data point');\n    }\n\n    // Find the mean of squared deviations between the\n    // mean value and each value.\n    return sumNthPowerDeviations(x, 2) / x.length;\n}\n\nmodule.exports = variance;\n","'use strict';\n/* @flow */\n\n/**\n * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).\n *\n * The standard score is the number of standard deviations an observation\n * or datum is above or below the mean. Thus, a positive standard score\n * represents a datum above the mean, while a negative standard score\n * represents a datum below the mean. It is a dimensionless quantity\n * obtained by subtracting the population mean from an individual raw\n * score and then dividing the difference by the population standard\n * deviation.\n *\n * The z-score is only defined if one knows the population parameters;\n * if one only has a sample set, then the analogous computation with\n * sample mean and sample standard deviation yields the\n * Student's t-statistic.\n *\n * @param {number} x\n * @param {number} mean\n * @param {number} standardDeviation\n * @return {number} z score\n * @example\n * zScore(78, 80, 5); // => -0.4\n */\nfunction zScore(x/*:number*/, mean/*:number*/, standardDeviation/*:number*/)/*:number*/ {\n    return (x - mean) / standardDeviation;\n}\n\nmodule.exports = zScore;\n"]}